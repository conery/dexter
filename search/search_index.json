{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Dexter Dexter (Double-Entry Expense Tracker) is a collection of command line applications for managing personal finances. Its main features are: the use double-entry bookkeeping to categorize expenses a workflow that focusses on efficiency, with extensive use of command completion, edit operations triggered by single keystrokes, and automatic fills based on patterns and previous records a new budget model that allows for zero-based budgeting entirely within the double-entry bookeeeping framework, without requiring virtual transactions or other extensions a database API that allows users to write their own scripts Dexter is written entirely in Python and can be installed with a pip command that pulls the sources from the GitHub repo. The only external dependence is MongoDB. Before running Dexter it is necessary to start the MongoDB server running locally. A planned update is to allow the option of connecting to a SQLite database. The overview section is recommended reading before installing Dexter and trying the examples in the tutorial.","title":"Overview"},{"location":"#welcome-to-dexter","text":"Dexter (Double-Entry Expense Tracker) is a collection of command line applications for managing personal finances. Its main features are: the use double-entry bookkeeping to categorize expenses a workflow that focusses on efficiency, with extensive use of command completion, edit operations triggered by single keystrokes, and automatic fills based on patterns and previous records a new budget model that allows for zero-based budgeting entirely within the double-entry bookeeeping framework, without requiring virtual transactions or other extensions a database API that allows users to write their own scripts Dexter is written entirely in Python and can be installed with a pip command that pulls the sources from the GitHub repo. The only external dependence is MongoDB. Before running Dexter it is necessary to start the MongoDB server running locally. A planned update is to allow the option of connecting to a SQLite database. The overview section is recommended reading before installing Dexter and trying the examples in the tutorial.","title":"Welcome to Dexter"},{"location":"accounts/","text":"Defining Accounts The central concept in double-entry bookkeeping is the idea that transactions move funds between accounts. When we create a new database we need to tell Dexter the names and types of all of our income, asset, expense, and liability accounts. Account names are defined in a plain text file. Dexter recognizes two different file formats: a .csv (comma separated values) file has a header line followed by one line for each account, specifying the names at attributes of each account. a .journal file has account statements in the Journal format used by hledger; each statement has the name of the account followed by tags that define the attributes. There is one example of each type of file in the tutorial data: Finances \u251c\u2500\u2500 accounts.csv \u251c\u2500\u2500 accounts.journal CSV Format for Accounts The first line in the CSV file is a header that defines the columns that are present in the file. The column names used by Dexter are: column definition example fullname the name of the account assets:bank:checking category account category (optional, see below) assets abbrev a short version of the column name (optional) checking parser rule set for parsing downloads (required if parsing CSVs) balance the initial account balance (optional) 1,000.00 date date for initial account balance (required if balance specified) 2024-12-31 Tip: When you create your own account file you can use a spreadsheet application. The columns can be defined in any order, and the file can have additional columns (they will be ignored). The only requirement is that column names shown above be entered exactly as they are shown, in all lower case. Then simply export the spreadsheet as a CSV file, making sure you include column names. fullname Dexter uses the same hierarchical account name conventions as GnuCash, hledger, and other systems, where the segments of a name are separated by colons. Generally the first segment is the account category, one of the basic account types of double-entry bookkeeping: assets are typically checking or savings accounts liabilities are credit cards and mortgages or other loans income is for salary and other types of income expenses are categories that describe what a purchase was for Some examples: income:salary assets:bank:checking expenses:travel liabilities:chase:visa Note : a fifth account category, equity , will be defined automatically. You don't need to include it in your account file. There is no limit on the number of segments in a name. A segment name may appear in more than one account name. For example, you can have expenses:car:insurance , expenses:home:insurance , and expenses:medical:insurance . A Note About Subaccounts Suppose you know you want subaccounts for types of food expenses, for example expenses:food:groceries and expenses:food:restaurant . That brings up a question: do you also need to define the \"parent\" account, expenses:food ? The answer is no, you are not required to define every intermediate level account. But there are two good reasons to do so: The parent account can serve as a \"miscellaneous\" or \"unclassified\" category. At some point you might have an expense you know you want to put in the food group but can't decide which subaccount to put it in, so just assign it to expenses.food (but if you have a lot of these it may be better to define expenses:food:misc for the random food expense). When you are allocating income to budget envelopes, you can assign an amount to expenses:food to cover all food expenses. Any expense that debits any food account, no matter where it is in the hierarchy, will take funds from the overall food envelope. If you want to use intermediate accounts like expenses:food , either for miscellaneous expenses or for budgeting, the account needs to be defined in the CSV file with other accounts. category If an account name starts with one of the four main account types the category will be inferred from the account name. Otherwise put the account type in the category column. abbrev There are two reasons to define an optional abbreviated name for an account. One use is to define a short name for an expense account so it can be used in reports. For example, suppose we want to print a table showing all food expenses before Jan 31, 2025. The select command (described later in Select Transactions ) will print that table: $ dex select --end 2025-01-31 --debit food 2025-01-02 chase:visa expenses:food:groceries $22.04 Safeway 2025-01-06 bank:checking expenses:food:groceries $77.42 Costco 2025-01-06 bank:checking expenses:food:groceries $6.99 Safeway 2025-01-14 chase:visa expenses:food:restaurant $40.12 Pizza Palace ... For long outputs the repetition of account name prefixes like \"expenses:food\" is going to make the table harder to read. If we specify abbreviations, e.g. groceries for expenses:food:groceries and visa for liabilities:chase:visa , we can include the --abbrev option on the command line to print a more readable table: $ dex select --end 2025-01-31 --debit food --abbrev 2025-01-02 visa groceries $22.04 Safeway 2025-01-06 checking groceries $77.42 Costco 2025-01-06 checking groceries $6.99 Safeway 2025-01-14 visa restaurant $40.12 Pizza Palace ... The second reason is that when we download CSV files for assets and liability accounts we want to rename the file so the base name (the part before the extension) is the account name. For example, if we have two bank accounts, one for checking and one for savings, we will download the records for each account separately. Rename the file for the checking account to checking.csv and the file for the savings account to savings.csv . When we run dex import to import a file, it will use the file name to figure out which account to use for the new postings. parser As noted previously, parsers are defined in the configuration file . There will typically be one parser for each data source. The parser column for these accounts will have the name of the configuration section without the csv. prefix, e.g. occu or chase . balance Use this column to enter the starting balance of an account. You can use it for assets (bank accounts) and, if using envelope budgeting , for expense accounts. Note that the initial contents of an envelope should be a negative number. For example, if you want to start out with $100 in the groceries envelope put -100.00 in the balance column. Journal File Format for Accounts Accounts can also be defined in a Journal file, using the syntax supported by hledger. Write an account statement for each account you want to define. the line starts with the word account following that write the name of the account (what would go in the fullname column of a CSV file) add a semicolon to start a comment add the remaining data, if any, in the form of tag: value pairs separated by commas The category tag can be omitted if the full name starts with one of the four basic categories ( assets , expenses , income , liabilities ). Here are some examples from accounts.journal in the example data: account assets:bank:checking ; category: assets, abbrev: checking, parser: occu account liabilities:chase:visa ; type: liabilities, abbrev: visa, parser: chase account income:yoyodyne ; abbrev: yoyodyne account expenses:food ; type: expenses account expenses:food:groceries ; type: expenses, abbrev: groceries Instead of putting a balance and date in a comment in the account add a transaction statement following the account statements. This is how to initialize the checking and savings account balances: 2024-12-31 initial balance assets:bank:checking $1,000.00 assets:bank:savings $2,500.00 equity Note : Dexter currently assumes all amounts are in US dollars. Reports and output tables will be formatted with a dollar sign. When you put an amount in a Journal file dollar signs and commas are optional. For negative numbers the minus sign can be written before or after the dollar sign: $-100.00 or -$100.00 .","title":"Defining Accounts"},{"location":"accounts/#defining-accounts","text":"The central concept in double-entry bookkeeping is the idea that transactions move funds between accounts. When we create a new database we need to tell Dexter the names and types of all of our income, asset, expense, and liability accounts. Account names are defined in a plain text file. Dexter recognizes two different file formats: a .csv (comma separated values) file has a header line followed by one line for each account, specifying the names at attributes of each account. a .journal file has account statements in the Journal format used by hledger; each statement has the name of the account followed by tags that define the attributes. There is one example of each type of file in the tutorial data: Finances \u251c\u2500\u2500 accounts.csv \u251c\u2500\u2500 accounts.journal","title":"Defining Accounts"},{"location":"accounts/#csv-format-for-accounts","text":"The first line in the CSV file is a header that defines the columns that are present in the file. The column names used by Dexter are: column definition example fullname the name of the account assets:bank:checking category account category (optional, see below) assets abbrev a short version of the column name (optional) checking parser rule set for parsing downloads (required if parsing CSVs) balance the initial account balance (optional) 1,000.00 date date for initial account balance (required if balance specified) 2024-12-31 Tip: When you create your own account file you can use a spreadsheet application. The columns can be defined in any order, and the file can have additional columns (they will be ignored). The only requirement is that column names shown above be entered exactly as they are shown, in all lower case. Then simply export the spreadsheet as a CSV file, making sure you include column names.","title":"CSV Format for Accounts"},{"location":"accounts/#fullname","text":"Dexter uses the same hierarchical account name conventions as GnuCash, hledger, and other systems, where the segments of a name are separated by colons. Generally the first segment is the account category, one of the basic account types of double-entry bookkeeping: assets are typically checking or savings accounts liabilities are credit cards and mortgages or other loans income is for salary and other types of income expenses are categories that describe what a purchase was for Some examples: income:salary assets:bank:checking expenses:travel liabilities:chase:visa Note : a fifth account category, equity , will be defined automatically. You don't need to include it in your account file. There is no limit on the number of segments in a name. A segment name may appear in more than one account name. For example, you can have expenses:car:insurance , expenses:home:insurance , and expenses:medical:insurance .","title":"fullname"},{"location":"accounts/#a-note-about-subaccounts","text":"Suppose you know you want subaccounts for types of food expenses, for example expenses:food:groceries and expenses:food:restaurant . That brings up a question: do you also need to define the \"parent\" account, expenses:food ? The answer is no, you are not required to define every intermediate level account. But there are two good reasons to do so: The parent account can serve as a \"miscellaneous\" or \"unclassified\" category. At some point you might have an expense you know you want to put in the food group but can't decide which subaccount to put it in, so just assign it to expenses.food (but if you have a lot of these it may be better to define expenses:food:misc for the random food expense). When you are allocating income to budget envelopes, you can assign an amount to expenses:food to cover all food expenses. Any expense that debits any food account, no matter where it is in the hierarchy, will take funds from the overall food envelope. If you want to use intermediate accounts like expenses:food , either for miscellaneous expenses or for budgeting, the account needs to be defined in the CSV file with other accounts.","title":"A Note About Subaccounts"},{"location":"accounts/#category","text":"If an account name starts with one of the four main account types the category will be inferred from the account name. Otherwise put the account type in the category column.","title":"category"},{"location":"accounts/#abbrev","text":"There are two reasons to define an optional abbreviated name for an account. One use is to define a short name for an expense account so it can be used in reports. For example, suppose we want to print a table showing all food expenses before Jan 31, 2025. The select command (described later in Select Transactions ) will print that table: $ dex select --end 2025-01-31 --debit food 2025-01-02 chase:visa expenses:food:groceries $22.04 Safeway 2025-01-06 bank:checking expenses:food:groceries $77.42 Costco 2025-01-06 bank:checking expenses:food:groceries $6.99 Safeway 2025-01-14 chase:visa expenses:food:restaurant $40.12 Pizza Palace ... For long outputs the repetition of account name prefixes like \"expenses:food\" is going to make the table harder to read. If we specify abbreviations, e.g. groceries for expenses:food:groceries and visa for liabilities:chase:visa , we can include the --abbrev option on the command line to print a more readable table: $ dex select --end 2025-01-31 --debit food --abbrev 2025-01-02 visa groceries $22.04 Safeway 2025-01-06 checking groceries $77.42 Costco 2025-01-06 checking groceries $6.99 Safeway 2025-01-14 visa restaurant $40.12 Pizza Palace ... The second reason is that when we download CSV files for assets and liability accounts we want to rename the file so the base name (the part before the extension) is the account name. For example, if we have two bank accounts, one for checking and one for savings, we will download the records for each account separately. Rename the file for the checking account to checking.csv and the file for the savings account to savings.csv . When we run dex import to import a file, it will use the file name to figure out which account to use for the new postings.","title":"abbrev"},{"location":"accounts/#parser","text":"As noted previously, parsers are defined in the configuration file . There will typically be one parser for each data source. The parser column for these accounts will have the name of the configuration section without the csv. prefix, e.g. occu or chase .","title":"parser"},{"location":"accounts/#balance","text":"Use this column to enter the starting balance of an account. You can use it for assets (bank accounts) and, if using envelope budgeting , for expense accounts. Note that the initial contents of an envelope should be a negative number. For example, if you want to start out with $100 in the groceries envelope put -100.00 in the balance column.","title":"balance"},{"location":"accounts/#journal-file-format-for-accounts","text":"Accounts can also be defined in a Journal file, using the syntax supported by hledger. Write an account statement for each account you want to define. the line starts with the word account following that write the name of the account (what would go in the fullname column of a CSV file) add a semicolon to start a comment add the remaining data, if any, in the form of tag: value pairs separated by commas The category tag can be omitted if the full name starts with one of the four basic categories ( assets , expenses , income , liabilities ). Here are some examples from accounts.journal in the example data: account assets:bank:checking ; category: assets, abbrev: checking, parser: occu account liabilities:chase:visa ; type: liabilities, abbrev: visa, parser: chase account income:yoyodyne ; abbrev: yoyodyne account expenses:food ; type: expenses account expenses:food:groceries ; type: expenses, abbrev: groceries Instead of putting a balance and date in a comment in the account add a transaction statement following the account statements. This is how to initialize the checking and savings account balances: 2024-12-31 initial balance assets:bank:checking $1,000.00 assets:bank:savings $2,500.00 equity Note : Dexter currently assumes all amounts are in US dollars. Reports and output tables will be formatted with a dollar sign. When you put an amount in a Journal file dollar signs and commas are optional. For negative numbers the minus sign can be written before or after the dollar sign: $-100.00 or -$100.00 .","title":"Journal File Format for Accounts"},{"location":"adjustments/","text":"Adjustments to Envelopes Envelopes are eventually going to have balances -- positive or negative -- that we don't like. As an example, suppose we have a run of bad luck with the car. In addition to new tires, we had a higher than expected repair bill and other expenses, so now the balance in the car expense account is +$1000, meaning the envelope is $1000 overdrawn. Here are some ways to deal with the situation. Do nothing. Trust that the amount set aside for the car budget will eventually resolve the situation. Realize we are not allocating enough for car expenses. Adjust the budget so that in future months we put more into the car and less someplace else. Do a one-time transfer from another envelope. As an example of the third option, suppose we have extra money in the home envelope because we haven't had as many home expenses as we budgeted for, and we're willing to move some of the excess over to the car envelope. This transaction will transfer $1000 from home to car : 2024-02-28 move $1K from home to car ; budget: expenses:home $1000.00 expenses:car $-1000.00 Note that the signs on the amounts are not intuitive: we are not \"adding to\" home by \"taking from\" car . Just the opposite, in fact. The debits and credits on this transaction need to be consistent with other transactions that involve these accounts: the positive amount on the debit to the home account is similar to transactions that debit the home account in a purchase, where it means \"take this amount from the envelope\" the credit to the car account, indicated by the minus sign, is comparable to credits in other transactions, for example if we return a purchase or when when money is allocated by a budget transaction; it means \"we are adding this much money to the envelope\" One other important note: this transaction should be tagged to make sure it is not included in reports that use the traditional definition of the expense account balances. Dexter can import transactions from a Journal file. In those files tags use the Ledger/hledger format of a tag name followed by a colon. In the database and in shell commands tags are denoted by a hash tag before the tag name.","title":"Adjustments"},{"location":"adjustments/#adjustments-to-envelopes","text":"Envelopes are eventually going to have balances -- positive or negative -- that we don't like. As an example, suppose we have a run of bad luck with the car. In addition to new tires, we had a higher than expected repair bill and other expenses, so now the balance in the car expense account is +$1000, meaning the envelope is $1000 overdrawn. Here are some ways to deal with the situation. Do nothing. Trust that the amount set aside for the car budget will eventually resolve the situation. Realize we are not allocating enough for car expenses. Adjust the budget so that in future months we put more into the car and less someplace else. Do a one-time transfer from another envelope. As an example of the third option, suppose we have extra money in the home envelope because we haven't had as many home expenses as we budgeted for, and we're willing to move some of the excess over to the car envelope. This transaction will transfer $1000 from home to car : 2024-02-28 move $1K from home to car ; budget: expenses:home $1000.00 expenses:car $-1000.00 Note that the signs on the amounts are not intuitive: we are not \"adding to\" home by \"taking from\" car . Just the opposite, in fact. The debits and credits on this transaction need to be consistent with other transactions that involve these accounts: the positive amount on the debit to the home account is similar to transactions that debit the home account in a purchase, where it means \"take this amount from the envelope\" the credit to the car account, indicated by the minus sign, is comparable to credits in other transactions, for example if we return a purchase or when when money is allocated by a budget transaction; it means \"we are adding this much money to the envelope\" One other important note: this transaction should be tagged to make sure it is not included in reports that use the traditional definition of the expense account balances. Dexter can import transactions from a Journal file. In those files tags use the Ledger/hledger format of a tag name followed by a colon. In the database and in shell commands tags are denoted by a hash tag before the tag name.","title":"Adjustments to Envelopes"},{"location":"api/","text":"Database API For those who want to write their own scripts...","title":"Database API"},{"location":"api/#database-api","text":"For those who want to write their own scripts...","title":"Database API"},{"location":"balance_expenses/","text":"Expense Account Balance The credits in a budget transaction have the same effect on the account as the credits in the Venmo example shown earlier. In both cases, the transaction decreases the balance in the account. A budget transaction at the beginning of the month sets a large negative balance on the account. For example, these are the credits from the example shown above: expenses:home $-3000.00 expenses:car $-1000.00 expenses:food $-1000.00 In this case we're setting the home balance to -$3000 and the car and food balances to -$1000. As purchases are recorded, any transaction that debits an expense will add a positive amount. The dinner at the restaurant debited the food account for $75: expenses:food $75.00 The balance increased (became less negative) and now sits at -$925. For any account, as long as the balance stays negative spending is within the budget. But as soon as it crosses over into being positive we have spent more than the allocation. The Debit Card Analogy A rough analogy is to think of an expense account as pre-paid debit card . At the beginning of a month the card is \"loaded\" with the budget amount for that category. Then throughout the month as the card is used for purchases the balance gets lower and lower. There are (at least) two problems with this analogy. First, the balance on a real debit card is a positive number, and using it for transactions lowers the balance. In our expense accounts the \"polarity\" is reversed. Adding money decreases the balance, and spending money increases it. The second is that our envelopes are expense accounts, but in real life a prepaid debit card is an asset. A real envelope full of cash has an objective value that lets it be traded or sold, while our expense accounts are abstractions (this is discussed more below in the section on Nominal Accounts ). In spite of these flaws the basic idea is similar: initialize the card/account with an amount that estimates how much we want to spend, and as we use the card/account the balance works toward $0, at which point we are out of funds. Excess Spending Running out of funds is not an issue. If a balance goes positive there is nothing that prevents additional transactions from debiting the account again. Suppose the car account has a balance of -$400 ( i.e. there is $400 in the car envelope). Buying tires for $600 will debit the account for that amount, and now the balance will be +$200. We can still buy gas and make other transactions that debit the account, those transactions will just push the balance higher. Automatic Rollover One of the important goals for our budgeting process was to be able to carry over any money left in an envelope so it is available for the following month. Using expense accounts to model envelopes gives us this ability automatically. Any balance in an expense account -- positive or negative -- is there at the start of the next budget period. To continue the car example from the previous section, suppose the final balance at the end of the month is +$350. The budget transaction for the new month will include a credit for $1000, and the balance is negative again, at -$650. Purchases Can Be Made from Any Account When we eat dinner at a restaurant we have a choice of how to pay for it. Typically we use a debit card (the modern equivalent of writing a check) or one of our credit cards. In these transactions we used a debit card at one restaurant and a credit card at the other: 2024-01-07 Chez Ray expenses:food:restaurant $75.00 assets:checking $-75.00 2024-01-17 Burger Palace expenses:food:restaurant $25.00 liabilities:chase:visa $-25.00 For budgeting purposes it doesn't matter which account was used for the credit (source) side of the transaction. Whenever a transaction debits an expense account the envelope balance is updated. After lunch at Burger Palace the food account will have -$1000 + $75 + $25 = -$900.","title":"Expense Account Balances"},{"location":"balance_expenses/#expense-account-balance","text":"The credits in a budget transaction have the same effect on the account as the credits in the Venmo example shown earlier. In both cases, the transaction decreases the balance in the account. A budget transaction at the beginning of the month sets a large negative balance on the account. For example, these are the credits from the example shown above: expenses:home $-3000.00 expenses:car $-1000.00 expenses:food $-1000.00 In this case we're setting the home balance to -$3000 and the car and food balances to -$1000. As purchases are recorded, any transaction that debits an expense will add a positive amount. The dinner at the restaurant debited the food account for $75: expenses:food $75.00 The balance increased (became less negative) and now sits at -$925. For any account, as long as the balance stays negative spending is within the budget. But as soon as it crosses over into being positive we have spent more than the allocation.","title":"Expense Account Balance"},{"location":"balance_expenses/#the-debit-card-analogy","text":"A rough analogy is to think of an expense account as pre-paid debit card . At the beginning of a month the card is \"loaded\" with the budget amount for that category. Then throughout the month as the card is used for purchases the balance gets lower and lower. There are (at least) two problems with this analogy. First, the balance on a real debit card is a positive number, and using it for transactions lowers the balance. In our expense accounts the \"polarity\" is reversed. Adding money decreases the balance, and spending money increases it. The second is that our envelopes are expense accounts, but in real life a prepaid debit card is an asset. A real envelope full of cash has an objective value that lets it be traded or sold, while our expense accounts are abstractions (this is discussed more below in the section on Nominal Accounts ). In spite of these flaws the basic idea is similar: initialize the card/account with an amount that estimates how much we want to spend, and as we use the card/account the balance works toward $0, at which point we are out of funds.","title":"The Debit Card Analogy"},{"location":"balance_expenses/#excess-spending","text":"Running out of funds is not an issue. If a balance goes positive there is nothing that prevents additional transactions from debiting the account again. Suppose the car account has a balance of -$400 ( i.e. there is $400 in the car envelope). Buying tires for $600 will debit the account for that amount, and now the balance will be +$200. We can still buy gas and make other transactions that debit the account, those transactions will just push the balance higher.","title":"Excess Spending"},{"location":"balance_expenses/#automatic-rollover","text":"One of the important goals for our budgeting process was to be able to carry over any money left in an envelope so it is available for the following month. Using expense accounts to model envelopes gives us this ability automatically. Any balance in an expense account -- positive or negative -- is there at the start of the next budget period. To continue the car example from the previous section, suppose the final balance at the end of the month is +$350. The budget transaction for the new month will include a credit for $1000, and the balance is negative again, at -$650.","title":"Automatic Rollover"},{"location":"balance_expenses/#purchases-can-be-made-from-any-account","text":"When we eat dinner at a restaurant we have a choice of how to pay for it. Typically we use a debit card (the modern equivalent of writing a check) or one of our credit cards. In these transactions we used a debit card at one restaurant and a credit card at the other: 2024-01-07 Chez Ray expenses:food:restaurant $75.00 assets:checking $-75.00 2024-01-17 Burger Palace expenses:food:restaurant $25.00 liabilities:chase:visa $-25.00 For budgeting purposes it doesn't matter which account was used for the credit (source) side of the transaction. Whenever a transaction debits an expense account the envelope balance is updated. After lunch at Burger Palace the food account will have -$1000 + $75 + $25 = -$900.","title":"Purchases Can Be Made from Any Account"},{"location":"balance_income/","text":"Income Account Balance When a database has a budget allocation transaction it changes how we interpret the balance for income accounts. Currently your income transactions probably all have the same general form as the example shown above: 2024-01-02 paycheck assets:checking $5000.00 income:yoyodyne $-5000.00 Unless there is a reason you have to return some income, all of the entries for the income account are credits and the balance keeps getting more and more negative. Now consider what happens when we include the budget transaction: 2024-01-02 fill envelopes ; budget: income:yoyodyne $5000.00 expenses:home $-3000.00 expenses:car $-1000.00 expenses:food $-1000.00 That transaction, like every other transaction, should be balanced. The sum of the credits to the expense accounts should match the amount debited to the income account. So one way to look at this transaction is that the income is being divided among all the expense accounts: the total over all credits (money put in envelopes) should equal the debit (the income amount). Giving Every Dollar a Job After including the budget transaction, if the income account balance is not $0 it means something is wrong. If the balance is less than $0 it means there is left over income that was not distributed to an envelope. If the amount is greater than $0 it means the budget is off -- we're trying to allocate more money than we have. When the balance is $0 we've successfully given every dollar a job. Note: \"Give every dollar a job\" does not mean \"spend every dollar.\" A monthly budget can include putting money into a savings account. We'll see how to do that below, in Using the Equity Account . COLA One way you can end up with unallocated income is if one of your income sources gives you a raise. A common workflow is to download CSV records from your bank, add them to the database, and print reports. When the balance reports shows the income account has an amount less than $0 it's a signal to edit your budget to make sure it matches your new income. Dexter's fill command creates a budget transaction automatically from one or more deposits. It uses a budget table defined in the configuration table. If a deposit is higher, due to a cost of living adjustment (COLA) or for some other reason, the transaction is unbalanced and the income account will have a positive balance. Interest Income Another common occurrence is that your asset accounts will earn interest each month. One way to deal with is to have a rule or a script that runs every month to compute the total earned in all accounts and insert a new budget transaction that allocates that amount to one of your envelopes: 2024-01-31 allocate interest income ; budget: income:interest $12.34 expenses:bank $-12.34 I have an envelope named bank that I use for annual credit card fees, the fee for renting a safe deposit box, and other random charges, so I just put interest there to help pay fees when they crop up. But of course you could put it in travel, restaurant, or any other place where it would be nice to have some \"found money.\"","title":"Income Account Balances"},{"location":"balance_income/#income-account-balance","text":"When a database has a budget allocation transaction it changes how we interpret the balance for income accounts. Currently your income transactions probably all have the same general form as the example shown above: 2024-01-02 paycheck assets:checking $5000.00 income:yoyodyne $-5000.00 Unless there is a reason you have to return some income, all of the entries for the income account are credits and the balance keeps getting more and more negative. Now consider what happens when we include the budget transaction: 2024-01-02 fill envelopes ; budget: income:yoyodyne $5000.00 expenses:home $-3000.00 expenses:car $-1000.00 expenses:food $-1000.00 That transaction, like every other transaction, should be balanced. The sum of the credits to the expense accounts should match the amount debited to the income account. So one way to look at this transaction is that the income is being divided among all the expense accounts: the total over all credits (money put in envelopes) should equal the debit (the income amount).","title":"Income Account Balance"},{"location":"balance_income/#giving-every-dollar-a-job","text":"After including the budget transaction, if the income account balance is not $0 it means something is wrong. If the balance is less than $0 it means there is left over income that was not distributed to an envelope. If the amount is greater than $0 it means the budget is off -- we're trying to allocate more money than we have. When the balance is $0 we've successfully given every dollar a job. Note: \"Give every dollar a job\" does not mean \"spend every dollar.\" A monthly budget can include putting money into a savings account. We'll see how to do that below, in Using the Equity Account .","title":"Giving Every Dollar a Job"},{"location":"balance_income/#cola","text":"One way you can end up with unallocated income is if one of your income sources gives you a raise. A common workflow is to download CSV records from your bank, add them to the database, and print reports. When the balance reports shows the income account has an amount less than $0 it's a signal to edit your budget to make sure it matches your new income. Dexter's fill command creates a budget transaction automatically from one or more deposits. It uses a budget table defined in the configuration table. If a deposit is higher, due to a cost of living adjustment (COLA) or for some other reason, the transaction is unbalanced and the income account will have a positive balance.","title":"COLA"},{"location":"balance_income/#interest-income","text":"Another common occurrence is that your asset accounts will earn interest each month. One way to deal with is to have a rule or a script that runs every month to compute the total earned in all accounts and insert a new budget transaction that allocates that amount to one of your envelopes: 2024-01-31 allocate interest income ; budget: income:interest $12.34 expenses:bank $-12.34 I have an envelope named bank that I use for annual credit card fees, the fee for renting a safe deposit box, and other random charges, so I just put interest there to help pay fees when they crop up. But of course you could put it in travel, restaurant, or any other place where it would be nice to have some \"found money.\"","title":"Interest Income"},{"location":"balances/","text":"Account Balances Before we introduce budget transactions we should review how account balances are computed. In double-entry bookkeeping the balance of an account is the sum of the inflows (debits) minus the sum of the outflows (credits). Here are a few example transactions (written in the Journal format used by hledger and other plain text accounting applications): 2024-01-02 paycheck assets:checking $5000.00 income:yoyodyne $-5000.00 2024-01-06 Tools R Us expenses:home $100.00 assets:checking $-100.00 2024-01-07 Chez Ray expenses:food:restaurant $75.00 assets:checking $-75.00 In a journal file the signs on the amounts indicate the direction the money flowed: + for a debit and - for a credit. The first transaction is for our monthly paycheck. It debits (adds to) the checking account, and credits an income source. The next two transactions show we bought some tools at a hardware store and paid for them using our checking account (either a paper check or a debit card), then ate at a restaurant, also paying for it directly from the checking account. In both cases the negative amount means funds moved out of the checking account and the positive amount means the money was moved into one of the expense accounts. Because the Journal format uses positve numbers for debits (inflows) and negative numbers for credit (outflows) all we need to do to compute a balance for an account is add the amounts on all lines that name the account. Looking at the lines above, the three lines that refer to assets:checking have amounts $5000, $-75, and $-100, so the balance is $4875. In the examples so far the expense account was debited, but it's worth noting that a transaction can credit an expense account. For example, suppose that lunch at the restaurant was with a friend, and the next day our friend used Venmo to reimburse us for their share. The best way to represent this is with a transaction that debits the checking account (it's an inflow into the account) and credits the food expense account. Note how the signs are the opposite of what they were in the original purchase: 2024-01-08 venmo from Sam assets:checking $35.00 expenses:food:restaurant $-35.00 This transaction has an impact on the balance of both accounts: the checking account now has $4875 (the previous balance) + $35, or $4910, and the restaurant account has $75 - $35, or $40. This command shows the balance of expenses:food , including all subcategories ( expenses:food:groceries , expenses:food:restaurant , etc ), from the start of the year through the date of the Venmo transaction: $ dex report expenses:food: --end 2024-01-10 expenses:food: \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 date \u2503 description \u2503 credit \u2503 debit \u2503 amount \u2503 balance \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 2024-01-01 \u2502 starting balance \u2502 \u2502 \u2502 \u2502 $0.00 \u2502 \u2502 2024-01-07 \u2502 Chez Ray \u2502 assets:checking \u2502 food:restaurant \u2502 $75.00 \u2502 $75.00 \u2502 \u2502 2024-01-08 \u2502 venmo from Sam \u2502 food:restaurant \u2502 assets:checking \u2502 \u2212$35.00 \u2502 $40.00 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Account Balances"},{"location":"balances/#account-balances","text":"Before we introduce budget transactions we should review how account balances are computed. In double-entry bookkeeping the balance of an account is the sum of the inflows (debits) minus the sum of the outflows (credits). Here are a few example transactions (written in the Journal format used by hledger and other plain text accounting applications): 2024-01-02 paycheck assets:checking $5000.00 income:yoyodyne $-5000.00 2024-01-06 Tools R Us expenses:home $100.00 assets:checking $-100.00 2024-01-07 Chez Ray expenses:food:restaurant $75.00 assets:checking $-75.00 In a journal file the signs on the amounts indicate the direction the money flowed: + for a debit and - for a credit. The first transaction is for our monthly paycheck. It debits (adds to) the checking account, and credits an income source. The next two transactions show we bought some tools at a hardware store and paid for them using our checking account (either a paper check or a debit card), then ate at a restaurant, also paying for it directly from the checking account. In both cases the negative amount means funds moved out of the checking account and the positive amount means the money was moved into one of the expense accounts. Because the Journal format uses positve numbers for debits (inflows) and negative numbers for credit (outflows) all we need to do to compute a balance for an account is add the amounts on all lines that name the account. Looking at the lines above, the three lines that refer to assets:checking have amounts $5000, $-75, and $-100, so the balance is $4875. In the examples so far the expense account was debited, but it's worth noting that a transaction can credit an expense account. For example, suppose that lunch at the restaurant was with a friend, and the next day our friend used Venmo to reimburse us for their share. The best way to represent this is with a transaction that debits the checking account (it's an inflow into the account) and credits the food expense account. Note how the signs are the opposite of what they were in the original purchase: 2024-01-08 venmo from Sam assets:checking $35.00 expenses:food:restaurant $-35.00 This transaction has an impact on the balance of both accounts: the checking account now has $4875 (the previous balance) + $35, or $4910, and the restaurant account has $75 - $35, or $40. This command shows the balance of expenses:food , including all subcategories ( expenses:food:groceries , expenses:food:restaurant , etc ), from the start of the year through the date of the Venmo transaction: $ dex report expenses:food: --end 2024-01-10 expenses:food: \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 date \u2503 description \u2503 credit \u2503 debit \u2503 amount \u2503 balance \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 2024-01-01 \u2502 starting balance \u2502 \u2502 \u2502 \u2502 $0.00 \u2502 \u2502 2024-01-07 \u2502 Chez Ray \u2502 assets:checking \u2502 food:restaurant \u2502 $75.00 \u2502 $75.00 \u2502 \u2502 2024-01-08 \u2502 venmo from Sam \u2502 food:restaurant \u2502 assets:checking \u2502 \u2212$35.00 \u2502 $40.00 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Account Balances"},{"location":"budget_trans/","text":"Budget Transactions The paycheck transaction at the beginning of the month deposited $5000 in our bank account. If we're using zero-based budgeting we'll want to distribute all of it to envelopes. Suppose this is our budget: Expense Category Amount Comment Home $3000 rent, household items, etc Car $1000 payment, fuel, misc expenses Food $1000 groceries, restaurants The key idea behind Dexter's approach to budgeting is to use expense accounts , not asset accounts, to represent envelopes. The transaction below, which we call a budget allocation transaction , allocates funds to envelopes according to our budget. Note that it debits income accounts and credits expense accounts . The credits are how we model the process of adding money to the envelope, and the debit is a record of where that money came from: 2024-01-02 fill envelopes ; budget: income:yoyodyne $5000.00 expenses:home $-3000.00 expenses:car $-1000.00 expenses:food $-1000.00 There's a lot going on there! Using the income account on the debit side makes it look like we're giving our salary back to the company. We're not, but it does mean we need a new interpretation for the balance of an income account. The balance on that account is now $5000 - $5000, or $0. That seems meaningless, but in fact it's very useful information, as we'll explain below. On the other side, what are all those credits to expense accounts doing? They certainly play havoc with the balances of those accounts. For example, when the credit to expenses:food is combined with the two transactions shown earlier the food account balance is -$1000 plus $40, for a total of -$960. But here also there is a method to our madness, to be explained shortly. Before we get to the explanations, though, there is an important point: Budget transactions are easily ignored. It's very easy to recover the original meanings of the balance of income and expense accounts by simply not including budget transactions in balance calculations. Here is the default report for food expenses after we add budget transactions: $ dex report expenses:food --end 2024-01-10 expenses:food \u2709\ufe0f \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 date \u2503 description \u2503 credit \u2503 debit \u2503 amount \u2503 balance \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 2024-01-01 \u2502 starting balance \u2502 \u2502 \u2502 \u2502 $0.00 \u2502 \u2502 2024-01-02 \u2502 fill envelopes \u2502 food \u2502 yoyodyne \u2502 \u2212$1000.00 \u2502 \u2212$1000.00 \u2502 \u2502 2024-01-07 \u2502 Chez Ray \u2502 assets:checking \u2502 food:restaurant \u2502 $75.00 \u2502 \u2212$925.00 \u2502 \u2502 2024-01-08 \u2502 venmo from Sam \u2502 food:restaurant \u2502 bank:checking \u2502 \u2212$35.00 \u2502 \u2212$960.00 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Note there is a small envelope icon in the title bar next to the account name, to remind us that budget transactions are used in balance calculations. If you want to exclude budget transactions add a --no_budget option to the shell command and you'll get the same report as before: $ dex report expenses:food --end 2024-01-10 --no_budget expenses:food: \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 date \u2503 description \u2503 credit \u2503 debit \u2503 amount \u2503 balance \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 2024-01-01 \u2502 starting balance \u2502 \u2502 \u2502 \u2502 $0.00 \u2502 \u2502 2024-01-07 \u2502 Chez Ray \u2502 assets:checking \u2502 food:restaurant \u2502 $75.00 \u2502 $75.00 \u2502 \u2502 2024-01-08 \u2502 venmo from Sam \u2502 food:restaurant \u2502 assets:checking \u2502 \u2212$35.00 \u2502 $40.00 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Budget Transactions"},{"location":"budget_trans/#budget-transactions","text":"The paycheck transaction at the beginning of the month deposited $5000 in our bank account. If we're using zero-based budgeting we'll want to distribute all of it to envelopes. Suppose this is our budget: Expense Category Amount Comment Home $3000 rent, household items, etc Car $1000 payment, fuel, misc expenses Food $1000 groceries, restaurants The key idea behind Dexter's approach to budgeting is to use expense accounts , not asset accounts, to represent envelopes. The transaction below, which we call a budget allocation transaction , allocates funds to envelopes according to our budget. Note that it debits income accounts and credits expense accounts . The credits are how we model the process of adding money to the envelope, and the debit is a record of where that money came from: 2024-01-02 fill envelopes ; budget: income:yoyodyne $5000.00 expenses:home $-3000.00 expenses:car $-1000.00 expenses:food $-1000.00 There's a lot going on there! Using the income account on the debit side makes it look like we're giving our salary back to the company. We're not, but it does mean we need a new interpretation for the balance of an income account. The balance on that account is now $5000 - $5000, or $0. That seems meaningless, but in fact it's very useful information, as we'll explain below. On the other side, what are all those credits to expense accounts doing? They certainly play havoc with the balances of those accounts. For example, when the credit to expenses:food is combined with the two transactions shown earlier the food account balance is -$1000 plus $40, for a total of -$960. But here also there is a method to our madness, to be explained shortly. Before we get to the explanations, though, there is an important point: Budget transactions are easily ignored. It's very easy to recover the original meanings of the balance of income and expense accounts by simply not including budget transactions in balance calculations. Here is the default report for food expenses after we add budget transactions: $ dex report expenses:food --end 2024-01-10 expenses:food \u2709\ufe0f \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 date \u2503 description \u2503 credit \u2503 debit \u2503 amount \u2503 balance \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 2024-01-01 \u2502 starting balance \u2502 \u2502 \u2502 \u2502 $0.00 \u2502 \u2502 2024-01-02 \u2502 fill envelopes \u2502 food \u2502 yoyodyne \u2502 \u2212$1000.00 \u2502 \u2212$1000.00 \u2502 \u2502 2024-01-07 \u2502 Chez Ray \u2502 assets:checking \u2502 food:restaurant \u2502 $75.00 \u2502 \u2212$925.00 \u2502 \u2502 2024-01-08 \u2502 venmo from Sam \u2502 food:restaurant \u2502 bank:checking \u2502 \u2212$35.00 \u2502 \u2212$960.00 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Note there is a small envelope icon in the title bar next to the account name, to remind us that budget transactions are used in balance calculations. If you want to exclude budget transactions add a --no_budget option to the shell command and you'll get the same report as before: $ dex report expenses:food --end 2024-01-10 --no_budget expenses:food: \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 date \u2503 description \u2503 credit \u2503 debit \u2503 amount \u2503 balance \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 2024-01-01 \u2502 starting balance \u2502 \u2502 \u2502 \u2502 $0.00 \u2502 \u2502 2024-01-07 \u2502 Chez Ray \u2502 assets:checking \u2502 food:restaurant \u2502 $75.00 \u2502 $75.00 \u2502 \u2502 2024-01-08 \u2502 venmo from Sam \u2502 food:restaurant \u2502 assets:checking \u2502 \u2212$35.00 \u2502 $40.00 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Budget Transactions"},{"location":"command_line/","text":"Command Line API Dexter is a command line application. After it is installed you can run it simply by typing \"dex\" and a command name that tells Dexter what you want to do (initialize a database, import records, print a report, etc ). Subcommands If you try running it with no arguments you will see a usage message: $ dex usage: dex [-h] [--dbname X] ... {config,info,init,import,export,...} The first part of the message lists command line options common to all commands, and the last part of the line is the list of all the command names. To get help for one of the commands, type the command name and then --help , e.g. $ dex init --help usage: dex init [-h] --file F [--force] options: -h, --help show this help message and exit --file F name of file with account definitions --force replace an existing database Options Most commands have options, which are typed after the command name. For example, this command prints a report (based on the tutorial database) that shows all food related expenses before April 15: $ dex report expenses:food: --end_date 2024-04-15 The output is a table (formatted with a Python library named Rich): REPL The review command is the best example of why we use a command line API for Dexter. When we run dex review the script queries the database to find all unpaired postings. The script then uses a \"read-eval-print loop\" (REPL) to display the postings one at a time. After it displays a posting it waits for user input to tell it how to fill in the missing information that is needed to create a new transaction. In this example, the CSV record was from a credit card account. The second line in the box shows the data extracted from the file: the account name, the amount, and a description: The gray boxes on the first and third lines are for values we can fill in. We have to supply a transaction description (top line) and the name of the expense account (bottom line). This is what the scren looks like after the user has supplied the required data. The comment and tags are left blank, but the account has been filled in: There are two important points in this example: The account name was entered using a library named readline . The name of the library might not be familiar, but you probably use it all the time: it's what shells use to implement command completion and command line editing. To enter that account name, I just had to type \"gr\" and hit the tab key; Dexter realized that was enough to complete the name to expenses:food:groceries . The description, which is shown in white letters, was suggested by Dexter. It looked at the description from the CSV file, which was in all capitals, and used a pattern matching rule to turn it into mixed case. In all it took six keystrokes to process this record: one to open the account editor, two to type the account name, tab to complete the name, return to close the editor, and one last keystroke to tell Dexter to save this transaction and move on to the next one.","title":"Command Line API"},{"location":"command_line/#command-line-api","text":"Dexter is a command line application. After it is installed you can run it simply by typing \"dex\" and a command name that tells Dexter what you want to do (initialize a database, import records, print a report, etc ).","title":"Command Line API"},{"location":"command_line/#subcommands","text":"If you try running it with no arguments you will see a usage message: $ dex usage: dex [-h] [--dbname X] ... {config,info,init,import,export,...} The first part of the message lists command line options common to all commands, and the last part of the line is the list of all the command names. To get help for one of the commands, type the command name and then --help , e.g. $ dex init --help usage: dex init [-h] --file F [--force] options: -h, --help show this help message and exit --file F name of file with account definitions --force replace an existing database","title":"Subcommands"},{"location":"command_line/#options","text":"Most commands have options, which are typed after the command name. For example, this command prints a report (based on the tutorial database) that shows all food related expenses before April 15: $ dex report expenses:food: --end_date 2024-04-15 The output is a table (formatted with a Python library named Rich):","title":"Options"},{"location":"command_line/#repl","text":"The review command is the best example of why we use a command line API for Dexter. When we run dex review the script queries the database to find all unpaired postings. The script then uses a \"read-eval-print loop\" (REPL) to display the postings one at a time. After it displays a posting it waits for user input to tell it how to fill in the missing information that is needed to create a new transaction. In this example, the CSV record was from a credit card account. The second line in the box shows the data extracted from the file: the account name, the amount, and a description: The gray boxes on the first and third lines are for values we can fill in. We have to supply a transaction description (top line) and the name of the expense account (bottom line). This is what the scren looks like after the user has supplied the required data. The comment and tags are left blank, but the account has been filled in: There are two important points in this example: The account name was entered using a library named readline . The name of the library might not be familiar, but you probably use it all the time: it's what shells use to implement command completion and command line editing. To enter that account name, I just had to type \"gr\" and hit the tab key; Dexter realized that was enough to complete the name to expenses:food:groceries . The description, which is shown in white letters, was suggested by Dexter. It looked at the description from the CSV file, which was in all capitals, and used a pattern matching rule to turn it into mixed case. In all it took six keystrokes to process this record: one to open the account editor, two to type the account name, tab to complete the name, return to close the editor, and one last keystroke to tell Dexter to save this transaction and move on to the next one.","title":"REPL"},{"location":"config/","text":"Configuration Dexter uses a configuration file to define settings used by various scripts. Many of these are cosmetic, for example colors to use when printing tables on the terminal. But there is one important part of the configuration that many users might need to edit. The parsers that extract data from CSV files downloaded from banks, credit card companies, and other financial institutions are defined in the configuration file. Dexter comes with a set of predefined parsers, but there are undoubtedly banks and card companies that use a format Dexter doesn't know about. TBD: Parsers for other widely used credit cards (American Express, Citi, and Apple (Goldman Sachs)) will be added soon. We also plan to add a section to the GitHub repo for user-contributed parsers. The sections on this page: where Dexter looks for configuration files how to create a template configuation file the structure of a configuration file how to define parsers Finding Configuration Files Dexter looks in the following locations, in order: a path specified by the --config option on the command line a path stored in an environment variable named DEX_CONFIG a file named dex.toml in in current directory (where the dex command is run) a default configuration file in the installed code Create a Template There are two ways a user can make a template to use as a starting point for their own configuration. The first is to copy the file from the tutorial. The file is named dex.toml and can be found in the top level of the tutorial data folder. The second is to use Dexter's config command. Simply type $ dex config and Dexter will print a template on the terminal. To save the file in the default location (a file named dex.toml in your project directory) just redirect the output: $ dex config > ./dex.toml The template defines two parsers. One is for Oregon Community Credit Union (OCCU), which has a format that should be typical of the one used by most banks and should be easily adapted for your bank. The other is for Chase credit cards used to make the tutorial data. It should be usable as is for all Chase cards. The Structure of a Configuration File As the filename extension .toml implies, configuration files use a standard format known as TOML. It's unlikely you'll need to know more than what is covered here, but if you're curious or do run into trouble the TOML documentation is at TOML: Tom's Obvious Minimal Language . A line that starts with a hash symbol ( # ) is a comment, and the file can include blank lines to improve readability. A TOML file is organized by section. A section name is written in brackets, e.g. [terminology] . A section can have subsections, which are indicated by periods in the name. The default configuration has a section named [csv] and then subsections named [csv.occu] and [occu.chase] . Configuration settings look like assignment statements in a programming language, with a name, an equal sign, and a value. Values can be numbers, dates, strings, or compound items like lists of strings. All of Dexter's configuration settings will be simple numbers or strings. Defining a Parser A parser consists of a set of rules for extracting data from a CSV file downloaded from a financial institution. The first step is to find out what information we have to work with in each CSV file. The first line in a file is header , which is a list of column names, separated by commas. Note: some CSV files omit the header line and just contain data. It's not likely you will get a file without column names from a financial institution, but if you do you'll need to edit the file and add a header. This is the header on a file from OCCU: \"Transaction ID\",\"Posting Date\",\"Effective Date\",\"Transaction Type\",\"Amount\",\"Check Number\",\"Reference Number\",\"Description\",\"Transaction Category\",\"Type\",\"Balance\",\"Memo\",\"Extended Description\" and here is the header in a file from Chase: Transaction Date,Post Date,Description,Category,Type,Amount,Memo It doesn't matter whether the names are enclosed in quotes, or whether a column name is a single word or multiple words. The order doesn't matter, either. Dexter will look for data using a columnn name, not a column position. Configuration Section If you are writing a new parser the first step is to add a new section to the configuration file. For example, if you have American Express cards, you might name the parser amex , and you'll add a new section named [csv.amex] . Rules When the import command reads a CSV file it creates one new Posting for each line in the CSV (described in Philosophy ). The new Posting has four attributes: description date amount credit (a boolean that is True if the posting is a credit, False if it is a debit) Every parser has exactly four configuration settings. The name to the left of the equal sign is one of the four attribute names shown above, and the value on the right side is an expression that tells the parser where to find the value for that attribute. Expressions The values on the right side of a setting are Python expressions. Even if you don't know Python you should be able to understand the expressions in the default configuration and generalize them to write your own expressions. To explain the sorts of things that can go into a Python expression the examples below are based on rules in the example configuration, starting with the simplest and working up to more complex rules. A more detailed description of what is allowed in Python expressions will be included in the Reference section on Parsers . date In the Python code the name rec (short for \"record\") refers to the current line in the CSV file. To access part of a line write the column name in brackets immediately after rec . For example, the transaction date in an OCCU download is in a column named \"Posting Date\", so the Python expression that refers to the date column on the current line is rec[\"Posting Date\"] . Here is the rule in the OCCU parser: date = 'rec[\"Posting Date\"]' That simply means \"use the \"Posting Date\" column from the CSV file as the value of the date in the new posting that will be added to the database.\" Notice an important detail: the expression on the right side of the rule has a string inside a string. The outer (single) quotes are needed to tell TOML that the attribute is a string, and the inner (double) quotes tell Python that \"Posting Date\" is string to use for the column name. In the Chase download the column has a slightly different name, using \"Post\" instead of \"Posting\". This is the rule in the Chase parser: date = 'rec[\"Post Date\"]' description A CSV file from Chase has a column named \"Description\" that has a brief description of a transaction. It's usually the name of a business, e.g. \"CHEVRON\" or \"IZAKAYA JAPANESE RESTAURANT\". So a simple rule for filling the description attribute of the new posting is to just copy the value from this column: description = 'rec[\"Description\"]' The rule for the OCCU download is a little more interesting: description = 'rec[\"Description\"] + rec[\"Extended Description\"]' In Python, if s and t are strings, the expression s + t means \"combine s and t into one longer string\". What's going on here is that neither column, by itself, has enough useful information. In some transactions we'll want the \"Description\" column, and in others we'll want the \"Extended Description\". The solution is to combine both columns into one long string and save that in the database. That's going to lead to some pretty ugly looking descriptions. But keep in mind, the next step in the overall workflow, after importing records, is to run a script that applies regular expressions to postings, and those regular expressions will usually clean things up. So if the parser saves a description like Transfer to PayPalPAYPAL INSTANT TRANSFER - INST XFER a regular expression can transform it into PayPal Payment A general rule: When writing expressions for the desciption attribute, make sure you save enough \"raw material\" from the CSV file so regular expressions later in the workflow have enough to work with. One final note: you can save a \"marker\" in the description so you (and the regular expression) can know where the two parts were in the CSV file. This rule will put a slash between the two fields from the CSV file: description = 'rec[\"Description\"] + \"/\" + rec[\"Extended Description\"]' That Python expression combines three strings (a column from the CSV, a slash, and another column) into one longer expression. Now the PayPal description will look like this: Transfer to PayPal/PAYPAL INSTANT TRANSFER - INST XFER amount The rule for the amount attribute needs to convert a string from the CSV file (all columns in a CSV file are strings) into a number, and to make sure the number is positive (all amounts on postings in our database are positive). Python's builtin float function is just what we need. If s is a string containing digits (and maybe a decimal point) the expression float(s) means \"convert s into a number\". To write the parser rule, just identify the column that has the transaction amount and pass that to float . Both OCCU and Chase use a column named \"Amount\" so the rule will have this expression: float(rec[\"Amount\"]) In looking at the downloads we can see that both CSV files have positive and negative amounts in this column. To make sure all our values are positive just pass the result of calling float to another builtin function, abs (for \"absolute value\"). The final rule is: amount = 'abs(float(rec[\"Amount\"]))' TBD : Parsers shows how to write a rule when a CSV file has separate columns for credit and debits. credit The last attribute we need to define is the credit attribute. The rule has this general form: credit = 'p(...)' where p is a \"predicate\", or in Python terminology, a Boolean expression. It the expression is True our new posting will be a credit, otherwise it will be a debit. If a CSV file is for an asset account, for example it comes from a bank and is for a checking or savings account, we want transactions that are withdrawals or purchases to become credits in our database. These will eventually be paired with a debit to an expense account to form a complete transaction. On the other hand, CSV records for deposits should become debits . In looking through a CSV file from OCCU it's apparent there are negative numbers in the amount column for purchases/withdrawals and positive numbers for deposits. So all we need to do is look at the sign in the \"Amount\" column. If there is a negative sign we want the new posting to be a credit. Python has a very useful string method named startswith that we can use for our rule. In Python, if s and t are strings, the expression s.startswith(t) is True if the letters in t occur at the beginning of the s . So to see if the amount column has a minus sign at the front the Python code is rec['Amount'].startswith(\"-\") . In English, the rule would be \"set credit to True if the first character in the Amount column is a minus sign\". This is how to write it in Python: credit = 'rec[\"Amount\"].startswith(\"-\")' For the Chase parser the same logic applies. If a transaction is a purchase we want it to be a credit, but if it's a return or a card payment we want it to be a debit. The \"Amount\" column in this file also has minus signs for credits, so the rule is the same as the rule for the OCCU parser. Final Notes on Writing Parsers Any column from the CSV file can be used in an expression. Some other columns you might find useful are memos (notes that might be included on an electronic check) and transaction types (where an entry might be a word like \"purchase\" or \"payment\"). Many organizations have started including \"category\" or \"transaction category\" columns. These are automatically generated and are often helpful. For example, if a business is known to be a restaurant, the category column might have \"Food & Drink\". A potential strategy for coming up with categories for purchases might be to save these columns as part of the description, maybe at the end, after a special character: IZAKAYA JAPANESE RESTAURANT / Food & Drink Then when you write the regular expressions used by the pair command (described in Regular Expressions ) you can write a rule that debits your restaurant account when it sees this credit. In my experience, however, these categories are inconsistent and not very useful. They are based solely on the name of the payee, and often have mistakes. For example, if you pay for admission to the Ford Theater, you would probably characterize it as entertainment, but the CSV download is likely going to call it an automotive expense.","title":"Configuration"},{"location":"config/#configuration","text":"Dexter uses a configuration file to define settings used by various scripts. Many of these are cosmetic, for example colors to use when printing tables on the terminal. But there is one important part of the configuration that many users might need to edit. The parsers that extract data from CSV files downloaded from banks, credit card companies, and other financial institutions are defined in the configuration file. Dexter comes with a set of predefined parsers, but there are undoubtedly banks and card companies that use a format Dexter doesn't know about. TBD: Parsers for other widely used credit cards (American Express, Citi, and Apple (Goldman Sachs)) will be added soon. We also plan to add a section to the GitHub repo for user-contributed parsers. The sections on this page: where Dexter looks for configuration files how to create a template configuation file the structure of a configuration file how to define parsers","title":"Configuration"},{"location":"config/#finding-configuration-files","text":"Dexter looks in the following locations, in order: a path specified by the --config option on the command line a path stored in an environment variable named DEX_CONFIG a file named dex.toml in in current directory (where the dex command is run) a default configuration file in the installed code","title":"Finding Configuration Files"},{"location":"config/#create-a-template","text":"There are two ways a user can make a template to use as a starting point for their own configuration. The first is to copy the file from the tutorial. The file is named dex.toml and can be found in the top level of the tutorial data folder. The second is to use Dexter's config command. Simply type $ dex config and Dexter will print a template on the terminal. To save the file in the default location (a file named dex.toml in your project directory) just redirect the output: $ dex config > ./dex.toml The template defines two parsers. One is for Oregon Community Credit Union (OCCU), which has a format that should be typical of the one used by most banks and should be easily adapted for your bank. The other is for Chase credit cards used to make the tutorial data. It should be usable as is for all Chase cards.","title":"Create a Template"},{"location":"config/#the-structure-of-a-configuration-file","text":"As the filename extension .toml implies, configuration files use a standard format known as TOML. It's unlikely you'll need to know more than what is covered here, but if you're curious or do run into trouble the TOML documentation is at TOML: Tom's Obvious Minimal Language . A line that starts with a hash symbol ( # ) is a comment, and the file can include blank lines to improve readability. A TOML file is organized by section. A section name is written in brackets, e.g. [terminology] . A section can have subsections, which are indicated by periods in the name. The default configuration has a section named [csv] and then subsections named [csv.occu] and [occu.chase] . Configuration settings look like assignment statements in a programming language, with a name, an equal sign, and a value. Values can be numbers, dates, strings, or compound items like lists of strings. All of Dexter's configuration settings will be simple numbers or strings.","title":"The Structure of a Configuration File"},{"location":"config/#defining-a-parser","text":"A parser consists of a set of rules for extracting data from a CSV file downloaded from a financial institution. The first step is to find out what information we have to work with in each CSV file. The first line in a file is header , which is a list of column names, separated by commas. Note: some CSV files omit the header line and just contain data. It's not likely you will get a file without column names from a financial institution, but if you do you'll need to edit the file and add a header. This is the header on a file from OCCU: \"Transaction ID\",\"Posting Date\",\"Effective Date\",\"Transaction Type\",\"Amount\",\"Check Number\",\"Reference Number\",\"Description\",\"Transaction Category\",\"Type\",\"Balance\",\"Memo\",\"Extended Description\" and here is the header in a file from Chase: Transaction Date,Post Date,Description,Category,Type,Amount,Memo It doesn't matter whether the names are enclosed in quotes, or whether a column name is a single word or multiple words. The order doesn't matter, either. Dexter will look for data using a columnn name, not a column position.","title":"Defining a Parser"},{"location":"config/#configuration-section","text":"If you are writing a new parser the first step is to add a new section to the configuration file. For example, if you have American Express cards, you might name the parser amex , and you'll add a new section named [csv.amex] .","title":"Configuration Section"},{"location":"config/#rules","text":"When the import command reads a CSV file it creates one new Posting for each line in the CSV (described in Philosophy ). The new Posting has four attributes: description date amount credit (a boolean that is True if the posting is a credit, False if it is a debit) Every parser has exactly four configuration settings. The name to the left of the equal sign is one of the four attribute names shown above, and the value on the right side is an expression that tells the parser where to find the value for that attribute.","title":"Rules"},{"location":"config/#expressions","text":"The values on the right side of a setting are Python expressions. Even if you don't know Python you should be able to understand the expressions in the default configuration and generalize them to write your own expressions. To explain the sorts of things that can go into a Python expression the examples below are based on rules in the example configuration, starting with the simplest and working up to more complex rules. A more detailed description of what is allowed in Python expressions will be included in the Reference section on Parsers .","title":"Expressions"},{"location":"config/#date","text":"In the Python code the name rec (short for \"record\") refers to the current line in the CSV file. To access part of a line write the column name in brackets immediately after rec . For example, the transaction date in an OCCU download is in a column named \"Posting Date\", so the Python expression that refers to the date column on the current line is rec[\"Posting Date\"] . Here is the rule in the OCCU parser: date = 'rec[\"Posting Date\"]' That simply means \"use the \"Posting Date\" column from the CSV file as the value of the date in the new posting that will be added to the database.\" Notice an important detail: the expression on the right side of the rule has a string inside a string. The outer (single) quotes are needed to tell TOML that the attribute is a string, and the inner (double) quotes tell Python that \"Posting Date\" is string to use for the column name. In the Chase download the column has a slightly different name, using \"Post\" instead of \"Posting\". This is the rule in the Chase parser: date = 'rec[\"Post Date\"]'","title":"date"},{"location":"config/#description","text":"A CSV file from Chase has a column named \"Description\" that has a brief description of a transaction. It's usually the name of a business, e.g. \"CHEVRON\" or \"IZAKAYA JAPANESE RESTAURANT\". So a simple rule for filling the description attribute of the new posting is to just copy the value from this column: description = 'rec[\"Description\"]' The rule for the OCCU download is a little more interesting: description = 'rec[\"Description\"] + rec[\"Extended Description\"]' In Python, if s and t are strings, the expression s + t means \"combine s and t into one longer string\". What's going on here is that neither column, by itself, has enough useful information. In some transactions we'll want the \"Description\" column, and in others we'll want the \"Extended Description\". The solution is to combine both columns into one long string and save that in the database. That's going to lead to some pretty ugly looking descriptions. But keep in mind, the next step in the overall workflow, after importing records, is to run a script that applies regular expressions to postings, and those regular expressions will usually clean things up. So if the parser saves a description like Transfer to PayPalPAYPAL INSTANT TRANSFER - INST XFER a regular expression can transform it into PayPal Payment A general rule: When writing expressions for the desciption attribute, make sure you save enough \"raw material\" from the CSV file so regular expressions later in the workflow have enough to work with. One final note: you can save a \"marker\" in the description so you (and the regular expression) can know where the two parts were in the CSV file. This rule will put a slash between the two fields from the CSV file: description = 'rec[\"Description\"] + \"/\" + rec[\"Extended Description\"]' That Python expression combines three strings (a column from the CSV, a slash, and another column) into one longer expression. Now the PayPal description will look like this: Transfer to PayPal/PAYPAL INSTANT TRANSFER - INST XFER","title":"description"},{"location":"config/#amount","text":"The rule for the amount attribute needs to convert a string from the CSV file (all columns in a CSV file are strings) into a number, and to make sure the number is positive (all amounts on postings in our database are positive). Python's builtin float function is just what we need. If s is a string containing digits (and maybe a decimal point) the expression float(s) means \"convert s into a number\". To write the parser rule, just identify the column that has the transaction amount and pass that to float . Both OCCU and Chase use a column named \"Amount\" so the rule will have this expression: float(rec[\"Amount\"]) In looking at the downloads we can see that both CSV files have positive and negative amounts in this column. To make sure all our values are positive just pass the result of calling float to another builtin function, abs (for \"absolute value\"). The final rule is: amount = 'abs(float(rec[\"Amount\"]))' TBD : Parsers shows how to write a rule when a CSV file has separate columns for credit and debits.","title":"amount"},{"location":"config/#credit","text":"The last attribute we need to define is the credit attribute. The rule has this general form: credit = 'p(...)' where p is a \"predicate\", or in Python terminology, a Boolean expression. It the expression is True our new posting will be a credit, otherwise it will be a debit. If a CSV file is for an asset account, for example it comes from a bank and is for a checking or savings account, we want transactions that are withdrawals or purchases to become credits in our database. These will eventually be paired with a debit to an expense account to form a complete transaction. On the other hand, CSV records for deposits should become debits . In looking through a CSV file from OCCU it's apparent there are negative numbers in the amount column for purchases/withdrawals and positive numbers for deposits. So all we need to do is look at the sign in the \"Amount\" column. If there is a negative sign we want the new posting to be a credit. Python has a very useful string method named startswith that we can use for our rule. In Python, if s and t are strings, the expression s.startswith(t) is True if the letters in t occur at the beginning of the s . So to see if the amount column has a minus sign at the front the Python code is rec['Amount'].startswith(\"-\") . In English, the rule would be \"set credit to True if the first character in the Amount column is a minus sign\". This is how to write it in Python: credit = 'rec[\"Amount\"].startswith(\"-\")' For the Chase parser the same logic applies. If a transaction is a purchase we want it to be a credit, but if it's a return or a card payment we want it to be a debit. The \"Amount\" column in this file also has minus signs for credits, so the rule is the same as the rule for the OCCU parser.","title":"credit"},{"location":"config/#final-notes-on-writing-parsers","text":"Any column from the CSV file can be used in an expression. Some other columns you might find useful are memos (notes that might be included on an electronic check) and transaction types (where an entry might be a word like \"purchase\" or \"payment\"). Many organizations have started including \"category\" or \"transaction category\" columns. These are automatically generated and are often helpful. For example, if a business is known to be a restaurant, the category column might have \"Food & Drink\". A potential strategy for coming up with categories for purchases might be to save these columns as part of the description, maybe at the end, after a special character: IZAKAYA JAPANESE RESTAURANT / Food & Drink Then when you write the regular expressions used by the pair command (described in Regular Expressions ) you can write a rule that debits your restaurant account when it sees this credit. In my experience, however, these categories are inconsistent and not very useful. They are based solely on the name of the payee, and often have mistakes. For example, if you pay for admission to the Ford Theater, you would probably characterize it as entertainment, but the CSV download is likely going to call it an automotive expense.","title":"Final Notes on Writing Parsers"},{"location":"db_server/","text":"Database Connections The current version of Dexter works with a NoQL database named MongoDB. It expects to connect to server running on your computer. A SQLite connection is in the works. When it is available users will be able to skip this step. Install MongoDB Unlike plain text accounting applications, Dexter stores transactions and other work products in a database. The easiest way to install MongoDB is to use Homebrew: $ brew tap mongodb/brew $ brew install mongodb-community Then start the server: $ brew services start mongodb-community The server should run automatically every time you restart your computer.","title":"Database Server"},{"location":"db_server/#install-mongodb","text":"Unlike plain text accounting applications, Dexter stores transactions and other work products in a database. The easiest way to install MongoDB is to use Homebrew: $ brew tap mongodb/brew $ brew install mongodb-community Then start the server: $ brew services start mongodb-community The server should run automatically every time you restart your computer.","title":"Install MongoDB"},{"location":"deb/","text":"Double-Entry Bookkeeping There are plenty of good descriptions of double-entry bookkeeping at other sites, including GnuCash , Beancount , and Accounting for Computer Scientists . This section is a quick overview of the basic ideas necessary to describe the philosophy behind Dexter. Accounts An account in a bookkeeping system is a source or a destination for money. A real account in the system corresponds to an real-world account like a bank account or credit card account. They have specific identifiers (the name of the company, account number, etc ) and, at any point in time, a balance that reflects the amount of money we own (in a bank account) or owe (to a credit card company). The two main types of real accounts are assets , which we own , like checking and savings accounts, and liabilities , like credit cards and loans, which are things we owe . A nominal account is more abstract. These accounts are used to model sources of income and categories for expenses . When we set up a bookkeeping system we define nominal accounts to suit our needs. A good example of the flexibility we have in defining a nominal accounts is to consider how to define categories for monthly expenses. We'll want set up accounts for the basic categories with names like home , car , food , and entertainment . But if the goal is to do a better job of controlling monthly expenses a person might want to replace food with separate groceries and restaurant accounts, with the idea that the latter is a discretionary expense that can be controlled. Most systems, including Dexter, allow accounts to be organized in a hierarchy, so we might have a generic food account along with subaccounts food:groceries and food:restaurant . Income is also an abstraction. There could just be one catch-all account named income that models all money that comes our way during a month, but a more useful structure would be to have different accounts for salary , interest , tips , etc . Each person will set up their own income accounts depending on how they earn money. Transactions Whenever we spend or earn money we want to record it as a transaction in the bookkeeping system. In the simplest kind of transaction there will be one source account and one destination account. For example, when our paycheck is deposited in our bank account, the source account is salary and the destination account is checking . When we make a purchase, the source account is where the funds are coming from, for exampe a checking account. The destination is the expense account set up for the type of purchase. Some more examples: if want to transfer some money to a savings account there would be a new transaction where the source is checking and the destination is savings . if we use our debit card to buy groceries there will be a transaction where the source is checking and the destination is groceries . if we pay for dinner using a credit card we need to add a transaction where the card account is the source and the restaurant account is the destination paying the credit card bill is another type of transfer, this time with checking account as source and the credit card account as destination. Note that an account can be on either side of a transaction. In some of these examples checking was the source account and in others it was the destination. A transaction can have any number of sources or destinations. As an example, suppose we buy $200 worth of stuff at Costco using our credit card. If $150 of that was for food and the remaining $50 for toilet paper, laundry soap, and other household supplies, the transaction could have one source (the credit card) and two destinations ( groceries and home ). Terminology In bookkeeping terminology, a source account is the credit account and the destination account is the debit account. The components of a transaction are called postings (or sometimes just \"posts\"). A posting has the name of an account, an amount, and an indication of whether the account is being used as the source (credit) or debit (destination). Historically businesses that used double-entry accounting would keep one journal, or ledger, for each account. When transactions were recorded, one posting was entered in the journal for the credit account and a matching posting was entered in the journal for the debit account. With modern accounting software the records are commonly stored in the same file or database. Here is how the Costco transaction from above might be shown in a text file that uses the Journal format of plain-text accounting applications (Dexter can also read and write files using this format): 2024-01-17 Costco groceries $150.00 ; cheese, wine, cookies for party home $50.00 ; TP, soap, misc household visa $-200.00 The first line describes the transaction itself. Below that are three postings, showing the account name and amount. In a Journal file the sign of the amount indicates whether the posting is a debit (positive amount) or credit (negative) amount. In the case $200 is coming from the visa account, with $150 going to groceries and $50 going to home . Transactions Should Be Balanced The heart of double-entry bookkeeping is the reuirement that each transaction should be balanced: the sum of the debits must match the sum of the credits. This requirement can help track down many different kinds of errors. Here are a few that I have been able to fix more quickly by using double-ended bookkeeping. Missing Transaction (I) It's easy to overlook an account if it is rarely used. If CSV records from an account are not included in the database, there may be \"dangling transfers.\" For example, if there is a transfer from account A to account B, but records from B were not imported, the finance tracker will have a posting showing a withdrawal from A but it won't find anything to balance it with. Missing Transactions (II) I have used several different web applications that aggregate transactions. They connect to financial institutions for you and collect all your records. The applications have their own finance tracking tools, but they will also let you export all your transactions to a CSV file. Unfortunately there can be errors here, too. I have seen \"gaps\" where a few days worth of transactions from a source were simply not included. Double-entry bookkeeping makes this sort of error is easy to find, as well, since the balance in our system won't match the balance reported by the bank or card company. Inverted Flow If we purchase something using a credit card, and then later return that item, the return shows up in the CSV file as a separate transaction. Depending on how the downloads are formatted, returns may be distinguished from purchases by inverting the sign on the amount (purchases are positive, returns are negative) or printing the amount in a different column. If returns are rare, and the amounts are small, it's easy to get mixed up and enter a return in the expense tracker as a purchase. What should be a credit (transfer out) of the expense account is recorded as a debit (transfer in). These errors will show up when \"reconciling\" a card payment: the total value of all purchases and returns should equal the amount of a payment. Dexter has tools that will help resolve these discrepencies.","title":"Double Entry Bookkeeping"},{"location":"deb/#double-entry-bookkeeping","text":"There are plenty of good descriptions of double-entry bookkeeping at other sites, including GnuCash , Beancount , and Accounting for Computer Scientists . This section is a quick overview of the basic ideas necessary to describe the philosophy behind Dexter.","title":"Double-Entry Bookkeeping"},{"location":"deb/#accounts","text":"An account in a bookkeeping system is a source or a destination for money. A real account in the system corresponds to an real-world account like a bank account or credit card account. They have specific identifiers (the name of the company, account number, etc ) and, at any point in time, a balance that reflects the amount of money we own (in a bank account) or owe (to a credit card company). The two main types of real accounts are assets , which we own , like checking and savings accounts, and liabilities , like credit cards and loans, which are things we owe . A nominal account is more abstract. These accounts are used to model sources of income and categories for expenses . When we set up a bookkeeping system we define nominal accounts to suit our needs. A good example of the flexibility we have in defining a nominal accounts is to consider how to define categories for monthly expenses. We'll want set up accounts for the basic categories with names like home , car , food , and entertainment . But if the goal is to do a better job of controlling monthly expenses a person might want to replace food with separate groceries and restaurant accounts, with the idea that the latter is a discretionary expense that can be controlled. Most systems, including Dexter, allow accounts to be organized in a hierarchy, so we might have a generic food account along with subaccounts food:groceries and food:restaurant . Income is also an abstraction. There could just be one catch-all account named income that models all money that comes our way during a month, but a more useful structure would be to have different accounts for salary , interest , tips , etc . Each person will set up their own income accounts depending on how they earn money.","title":"Accounts"},{"location":"deb/#transactions","text":"Whenever we spend or earn money we want to record it as a transaction in the bookkeeping system. In the simplest kind of transaction there will be one source account and one destination account. For example, when our paycheck is deposited in our bank account, the source account is salary and the destination account is checking . When we make a purchase, the source account is where the funds are coming from, for exampe a checking account. The destination is the expense account set up for the type of purchase. Some more examples: if want to transfer some money to a savings account there would be a new transaction where the source is checking and the destination is savings . if we use our debit card to buy groceries there will be a transaction where the source is checking and the destination is groceries . if we pay for dinner using a credit card we need to add a transaction where the card account is the source and the restaurant account is the destination paying the credit card bill is another type of transfer, this time with checking account as source and the credit card account as destination. Note that an account can be on either side of a transaction. In some of these examples checking was the source account and in others it was the destination. A transaction can have any number of sources or destinations. As an example, suppose we buy $200 worth of stuff at Costco using our credit card. If $150 of that was for food and the remaining $50 for toilet paper, laundry soap, and other household supplies, the transaction could have one source (the credit card) and two destinations ( groceries and home ).","title":"Transactions"},{"location":"deb/#terminology","text":"In bookkeeping terminology, a source account is the credit account and the destination account is the debit account. The components of a transaction are called postings (or sometimes just \"posts\"). A posting has the name of an account, an amount, and an indication of whether the account is being used as the source (credit) or debit (destination). Historically businesses that used double-entry accounting would keep one journal, or ledger, for each account. When transactions were recorded, one posting was entered in the journal for the credit account and a matching posting was entered in the journal for the debit account. With modern accounting software the records are commonly stored in the same file or database. Here is how the Costco transaction from above might be shown in a text file that uses the Journal format of plain-text accounting applications (Dexter can also read and write files using this format): 2024-01-17 Costco groceries $150.00 ; cheese, wine, cookies for party home $50.00 ; TP, soap, misc household visa $-200.00 The first line describes the transaction itself. Below that are three postings, showing the account name and amount. In a Journal file the sign of the amount indicates whether the posting is a debit (positive amount) or credit (negative) amount. In the case $200 is coming from the visa account, with $150 going to groceries and $50 going to home .","title":"Terminology"},{"location":"deb/#transactions-should-be-balanced","text":"The heart of double-entry bookkeeping is the reuirement that each transaction should be balanced: the sum of the debits must match the sum of the credits. This requirement can help track down many different kinds of errors. Here are a few that I have been able to fix more quickly by using double-ended bookkeeping.","title":"Transactions Should Be Balanced"},{"location":"deb/#missing-transaction-i","text":"It's easy to overlook an account if it is rarely used. If CSV records from an account are not included in the database, there may be \"dangling transfers.\" For example, if there is a transfer from account A to account B, but records from B were not imported, the finance tracker will have a posting showing a withdrawal from A but it won't find anything to balance it with.","title":"Missing Transaction (I)"},{"location":"deb/#missing-transactions-ii","text":"I have used several different web applications that aggregate transactions. They connect to financial institutions for you and collect all your records. The applications have their own finance tracking tools, but they will also let you export all your transactions to a CSV file. Unfortunately there can be errors here, too. I have seen \"gaps\" where a few days worth of transactions from a source were simply not included. Double-entry bookkeeping makes this sort of error is easy to find, as well, since the balance in our system won't match the balance reported by the bank or card company.","title":"Missing Transactions (II)"},{"location":"deb/#inverted-flow","text":"If we purchase something using a credit card, and then later return that item, the return shows up in the CSV file as a separate transaction. Depending on how the downloads are formatted, returns may be distinguished from purchases by inverting the sign on the amount (purchases are positive, returns are negative) or printing the amount in a different column. If returns are rare, and the amounts are small, it's easy to get mixed up and enter a return in the expense tracker as a purchase. What should be a credit (transfer out) of the expense account is recorded as a debit (transfer in). These errors will show up when \"reconciling\" a card payment: the total value of all purchases and returns should equal the amount of a payment. Dexter has tools that will help resolve these discrepencies.","title":"Inverted Flow"},{"location":"dex/","text":"Shell Command The shell command to run Dexter has the general form of $ dex CMND [OPTIONS] where CMND is the name of an operation that implements a step in the expense tracker workflow. Before we describe the commands there is some important background information you need to know. Those topics, covered on this page, are: the configuration file connecting to a database running commands in preview mode options for commands Configuration File The configuration file we'll use in the tutorial is a file named dex.toml in the top level of the project folder: Finances \u251c\u2500\u2500 dex.toml ... You do not need to make any changes to this file in order to run the example commands in the tutorial, but you should know that it exists. Many of the settings are cosmetic, for example colors to use when printing tables in the terminal window, and names to use as alternatives to \"debit\" and \"credit\". If you want to make any changes you can find details about the file format in the section on Configuration . You could edit dex.toml but a better idea would be to copy that file and make changes in the copy. You can tell Dexter to use an alternative configuration file with the --config option: $ dex --config my_dex_config.toml ... Connecting to a Database Dexter stores account names, transactions, and other data in a database. By default it uses a popular NoSQL database server named MongoDB. Coming soon: users will have the option of using SQLite. Dexter looks in the configuration file to find the name of the database. The default name, speficifed in dex.toml , is dex . You can specify an alternative name with the --db option: $ dex --db my_dex_db ... Preview Mode Sometimes it's helpful to know how Dexter will process some data before you actually add it to the database. A good example is the import command, which will read data from CSV files downloaded from a bank or credit card company. If you want a preview of what will be added to the database use the --preview option (which can be abbreviated to --pre ), e.g. $ dex --pre import Downloads/apr/*.csv Options for Commands The --config , --db , and --preview options can be used with any Dexter command. There are also options that pertain to specific commands. For example, when importing CSV files we can tell Dexter to use transactions within a specified date range. To see the list of options for a command, enter the command name and then type --help after the command name: $ dex import --help usage: dex import [-h] [--account A] [--start_date D] [--end_date D] [--month D] [--regexp] F [F ...] positional arguments: F name(s) of file(s) with records to add options: -h, --help show this help message and exit --account A account name --start_date D starting date --end_date D ending date --month D add records only for this month --regexp CSV files have regular expression definitions There is an important detail in that \"usage\" string: command-specific options need to be entered after the command name. For example, this is how we would get a preview of records with dates before Apr 15, 2024: $ dex --preview import --end_date 2024-04-15 Downloads/apr/*csv Note that --preview , which is defined for all commands, goes before the command name, and --end_date is after the command name. You'll find more information about command line options at Command Line Options .","title":"Shell Command"},{"location":"dex/#shell-command","text":"The shell command to run Dexter has the general form of $ dex CMND [OPTIONS] where CMND is the name of an operation that implements a step in the expense tracker workflow. Before we describe the commands there is some important background information you need to know. Those topics, covered on this page, are: the configuration file connecting to a database running commands in preview mode options for commands","title":"Shell Command"},{"location":"dex/#configuration-file","text":"The configuration file we'll use in the tutorial is a file named dex.toml in the top level of the project folder: Finances \u251c\u2500\u2500 dex.toml ... You do not need to make any changes to this file in order to run the example commands in the tutorial, but you should know that it exists. Many of the settings are cosmetic, for example colors to use when printing tables in the terminal window, and names to use as alternatives to \"debit\" and \"credit\". If you want to make any changes you can find details about the file format in the section on Configuration . You could edit dex.toml but a better idea would be to copy that file and make changes in the copy. You can tell Dexter to use an alternative configuration file with the --config option: $ dex --config my_dex_config.toml ...","title":"Configuration File"},{"location":"dex/#connecting-to-a-database","text":"Dexter stores account names, transactions, and other data in a database. By default it uses a popular NoSQL database server named MongoDB. Coming soon: users will have the option of using SQLite. Dexter looks in the configuration file to find the name of the database. The default name, speficifed in dex.toml , is dex . You can specify an alternative name with the --db option: $ dex --db my_dex_db ...","title":"Connecting to a Database"},{"location":"dex/#preview-mode","text":"Sometimes it's helpful to know how Dexter will process some data before you actually add it to the database. A good example is the import command, which will read data from CSV files downloaded from a bank or credit card company. If you want a preview of what will be added to the database use the --preview option (which can be abbreviated to --pre ), e.g. $ dex --pre import Downloads/apr/*.csv","title":"Preview Mode"},{"location":"dex/#options-for-commands","text":"The --config , --db , and --preview options can be used with any Dexter command. There are also options that pertain to specific commands. For example, when importing CSV files we can tell Dexter to use transactions within a specified date range. To see the list of options for a command, enter the command name and then type --help after the command name: $ dex import --help usage: dex import [-h] [--account A] [--start_date D] [--end_date D] [--month D] [--regexp] F [F ...] positional arguments: F name(s) of file(s) with records to add options: -h, --help show this help message and exit --account A account name --start_date D starting date --end_date D ending date --month D add records only for this month --regexp CSV files have regular expression definitions There is an important detail in that \"usage\" string: command-specific options need to be entered after the command name. For example, this is how we would get a preview of records with dates before Apr 15, 2024: $ dex --preview import --end_date 2024-04-15 Downloads/apr/*csv Note that --preview , which is defined for all commands, goes before the command name, and --end_date is after the command name. You'll find more information about command line options at Command Line Options .","title":"Options for Commands"},{"location":"dex_add/","text":"Command Line Application How to run dex","title":"Command Line Application"},{"location":"dex_add/#command-line-application","text":"How to run dex","title":"Command Line Application"},{"location":"dex_import/","text":"dex import The import command parses one or more CSV files and adds new Postings to the database. Usage $ dex import [-h] [--account A] [--start_date D] [--end_date D] [--month D] [--regexp] F [F ...] positional arguments: F name(s) of file(s) with records to add options: -h, --help show this help message and exit --account A account name --start_date D starting date --end_date D ending date --month D add records only for this month The import command adds new records to the database. There are two kinds of data: transactions downloaded from a financial institution, which will become postings in the database regular expression rules used by the pair and review commands. Importing Regular Expressions If you want to import regular expresion rules, include the --regexp option on the command line: $ dex import --regexp F The tutorial data includes a file named regexp.csv you can use as a starting point for your own rules. The file format and instructions for creating rules are explained in Regular Expressions . Importing Financial Records By default Dexter assumes you want to import financial records, so if you type $ dex import F1 Dexter will assume the file F1 contains transactions. The file name extension tells Dexter what file format to expect. A .journal extension means the file contains Journal commands. Currently only account commands and transaction definitions are recognized by Dexter. A .csv extension means the file contains transactions downloaded from a financial institution. Journal files are meant to be used to initialize a new database (using the dex init command) or to import a small number of transactions, for example budget transactions. The remainder of this page has instructions for importing CSV files. Import a Single Transaction File To import a single file just specify the file name and use the --account option to tell Dexter which account to use for the new postings. Suppose you log in to your bank and download the transactions for your checking account. The bank web site will give the file a name that may or may not include the account name. Let's suppose it's simply \"Download.csv\" and your browser puts it in your main Downloads folder. This command will import those records as postings to the your checking account in the database: $ dex import ~/Downloads/Download.csv --account checking The --account option tells Dexter to look up the account with the abbreviated name checking , and to use the parser associated with that account to process every record in the file. If the file name is the same as the abbreviated name you can omit the --account option. For example, if you download the CSV file, then move it to the Downloads folder in your project directory and rename it with the account name, you don't need to specify the name with --account : $ mv ~/Downloads/Download.csv ./Downloads/checking.csv $ dex import Downloads/checking.csv Import Multiple CSV Files It's often more efficient to do a \"bulk import\" of several CSV files. In order to do this each file needs to have the name of an account. You can't use --account because the files belong to different accounts. For example, if your project's Download folder has files named checking.csv and savings.csv you can use one command to import them both: $ dex import Downloads/checking.csv Downloads/savings.csv If all the CSV files in Downloads are named for accounts you can also just type $ dex import Downloads/*.csv Is Bulk Import Really More Efficient? It takes a bit of work to organize downloads before a bulk import. This is a common situation: log in to the bank web site, download files from each account the bank gives them all the same name ( Download.csv ) so your browser puts them in your main Downloads with a generic name like Download.csv the files have to be renamed and moved to your project Download folder, e.g. $ mv ~/Downloads/Download.csv ./Downloads/checking.csv Although that seems like a lot of work it is probably worth the effort, for several reasons. If you don't rename the files you can accumulate a lot of duplicate names like Download (1).csv , Download (2).csv , etc , depending on how many accounts you have at the bank. You'll have to remember which file goes with which account in order to give the right name with the --account option wheh you import them one at a time. If you get into a pattern of download, move, download the next, move, ... it's easier to get the names correct. And finally, if you select the \"year to date\" option at the bank web site your CSV file will contain all the transactions for that account. Dexter checks to make sure it doesn't re-import a record, so it's OK to import a file that has all records for the year. Now you'll have CSV files, with names that reflect the account they came from, that can be used for other purposes as well. TBD: Working with Aggregators There are several web sites that serve as \"aggregators\". They can connect to your banks and credit card companies and download all of your records for you. Then you just need to log in to the aggregator and do one download to get those records. A future extension will allow parsers to specify a column in the CSV file to use as the account name.","title":"dex import"},{"location":"dex_import/#dex-import","text":"The import command parses one or more CSV files and adds new Postings to the database.","title":"dex import"},{"location":"dex_import/#usage","text":"$ dex import [-h] [--account A] [--start_date D] [--end_date D] [--month D] [--regexp] F [F ...] positional arguments: F name(s) of file(s) with records to add options: -h, --help show this help message and exit --account A account name --start_date D starting date --end_date D ending date --month D add records only for this month The import command adds new records to the database. There are two kinds of data: transactions downloaded from a financial institution, which will become postings in the database regular expression rules used by the pair and review commands.","title":"Usage"},{"location":"dex_import/#importing-regular-expressions","text":"If you want to import regular expresion rules, include the --regexp option on the command line: $ dex import --regexp F The tutorial data includes a file named regexp.csv you can use as a starting point for your own rules. The file format and instructions for creating rules are explained in Regular Expressions .","title":"Importing Regular Expressions"},{"location":"dex_import/#importing-financial-records","text":"By default Dexter assumes you want to import financial records, so if you type $ dex import F1 Dexter will assume the file F1 contains transactions. The file name extension tells Dexter what file format to expect. A .journal extension means the file contains Journal commands. Currently only account commands and transaction definitions are recognized by Dexter. A .csv extension means the file contains transactions downloaded from a financial institution. Journal files are meant to be used to initialize a new database (using the dex init command) or to import a small number of transactions, for example budget transactions. The remainder of this page has instructions for importing CSV files.","title":"Importing Financial Records"},{"location":"dex_import/#import-a-single-transaction-file","text":"To import a single file just specify the file name and use the --account option to tell Dexter which account to use for the new postings. Suppose you log in to your bank and download the transactions for your checking account. The bank web site will give the file a name that may or may not include the account name. Let's suppose it's simply \"Download.csv\" and your browser puts it in your main Downloads folder. This command will import those records as postings to the your checking account in the database: $ dex import ~/Downloads/Download.csv --account checking The --account option tells Dexter to look up the account with the abbreviated name checking , and to use the parser associated with that account to process every record in the file. If the file name is the same as the abbreviated name you can omit the --account option. For example, if you download the CSV file, then move it to the Downloads folder in your project directory and rename it with the account name, you don't need to specify the name with --account : $ mv ~/Downloads/Download.csv ./Downloads/checking.csv $ dex import Downloads/checking.csv","title":"Import a Single Transaction File"},{"location":"dex_import/#import-multiple-csv-files","text":"It's often more efficient to do a \"bulk import\" of several CSV files. In order to do this each file needs to have the name of an account. You can't use --account because the files belong to different accounts. For example, if your project's Download folder has files named checking.csv and savings.csv you can use one command to import them both: $ dex import Downloads/checking.csv Downloads/savings.csv If all the CSV files in Downloads are named for accounts you can also just type $ dex import Downloads/*.csv","title":"Import Multiple CSV Files"},{"location":"dex_import/#is-bulk-import-really-more-efficient","text":"It takes a bit of work to organize downloads before a bulk import. This is a common situation: log in to the bank web site, download files from each account the bank gives them all the same name ( Download.csv ) so your browser puts them in your main Downloads with a generic name like Download.csv the files have to be renamed and moved to your project Download folder, e.g. $ mv ~/Downloads/Download.csv ./Downloads/checking.csv Although that seems like a lot of work it is probably worth the effort, for several reasons. If you don't rename the files you can accumulate a lot of duplicate names like Download (1).csv , Download (2).csv , etc , depending on how many accounts you have at the bank. You'll have to remember which file goes with which account in order to give the right name with the --account option wheh you import them one at a time. If you get into a pattern of download, move, download the next, move, ... it's easier to get the names correct. And finally, if you select the \"year to date\" option at the bank web site your CSV file will contain all the transactions for that account. Dexter checks to make sure it doesn't re-import a record, so it's OK to import a file that has all records for the year. Now you'll have CSV files, with names that reflect the account they came from, that can be used for other purposes as well.","title":"Is Bulk Import Really More Efficient?"},{"location":"dex_import/#tbd-working-with-aggregators","text":"There are several web sites that serve as \"aggregators\". They can connect to your banks and credit card companies and download all of your records for you. Then you just need to log in to the aggregator and do one download to get those records. A future extension will allow parsers to specify a column in the CSV file to use as the account name.","title":"TBD: Working with Aggregators"},{"location":"dex_init/","text":"dex init The init command initializes a new database using descriptions of accounts in a CSV or Journal file. Usage $ dex init --help usage: dex init [-h] [--force] F positional arguments: F name of file with account definitions options: -h, --help show this help message and exit The command has one argument, the name of the account file. The format of the file will be inferred from the filename extension, either .csv or .journal . See Defining Accounts for details on how to define account attributes in each file format. Database Name Dexter looks for the name to use for the new database in the following locations, in order: the value of the --db command line option the value of an environment variable named DEX_DB the name defined in the configuration file If no name is found Dexter prints an error message and exits. If there is already a database with that name Dexter prints a warning and exits. Use --force if you want Dexter to erase the old database and replace it with the new one. Example To create a new database named test using the account definitions in my_accounts.csv : $ dex --db test my_accounts.csv","title":"dex init"},{"location":"dex_init/#dex-init","text":"The init command initializes a new database using descriptions of accounts in a CSV or Journal file.","title":"dex init"},{"location":"dex_init/#usage","text":"$ dex init --help usage: dex init [-h] [--force] F positional arguments: F name of file with account definitions options: -h, --help show this help message and exit The command has one argument, the name of the account file. The format of the file will be inferred from the filename extension, either .csv or .journal . See Defining Accounts for details on how to define account attributes in each file format.","title":"Usage"},{"location":"dex_init/#database-name","text":"Dexter looks for the name to use for the new database in the following locations, in order: the value of the --db command line option the value of an environment variable named DEX_DB the name defined in the configuration file If no name is found Dexter prints an error message and exits. If there is already a database with that name Dexter prints a warning and exits. Use --force if you want Dexter to erase the old database and replace it with the new one.","title":"Database Name"},{"location":"dex_init/#example","text":"To create a new database named test using the account definitions in my_accounts.csv : $ dex --db test my_accounts.csv","title":"Example"},{"location":"dex_install/","text":"Installation OS Versions These instructions are for macOS and should work on Linux. Instructions for Powershell are planned. Overview Dexter is a command line application. The shell command to run it has the general form of $ dex CMND [OPTIONS] where CMND is the name of an operation (initialize new database, import CSVs, etc ) and OPTIONS vary from one command to another. A typical session with Dexter starts with going to the folder where you work on your finances and running Dexter commands to carry out your expense tracking workflow: $ cd Finances $ dex report --audit $ dex import Downloads/*.csv $ dex pair ... Virtual Environment Dexter depends on a several third-party libraries. We recommend setting up a new virtual environment for Dexter and its dependences. Start by choosing a Python version. Dexter requires Python 3.13 or higher: $ pyenv shell 3.13.1 Make a new environment based on the selected Python. You can name it anything; this example makes an environment named dexter : $ pyenv virtualenv dexter Run pip to download and install Dexter: $ pip install git+https://github.com/conery/dexter.git Help Messages To test the installation ask dex to print a help message. If you run dex with no arguments you'll see an abbreviated help message: $ dex usage: dex [-h] [--dbname X] [--log X] [--preview] [--config F] {config,init,import,...} Use -h or --help to see a longer message: $ dex -h usage: dex [-h] [--dbname X] [--log X] [--preview] [--config F] {config,init,import,...} options: -h, --help show this help message and exit --dbname X database name --log X --preview --config F TOML file with configuration settings subcommands: config print default config file init initialize a database import add new records from files ... To print the help message for a subcommand, type the command name before typing -h or --help , e.g. $ dex init --help usage: dex init [-h] --file F options: -h, --help show this help message and exit --file F name of file with account definitions","title":"Dexter"},{"location":"dex_install/#installation","text":"OS Versions These instructions are for macOS and should work on Linux. Instructions for Powershell are planned.","title":"Installation"},{"location":"dex_install/#overview","text":"Dexter is a command line application. The shell command to run it has the general form of $ dex CMND [OPTIONS] where CMND is the name of an operation (initialize new database, import CSVs, etc ) and OPTIONS vary from one command to another. A typical session with Dexter starts with going to the folder where you work on your finances and running Dexter commands to carry out your expense tracking workflow: $ cd Finances $ dex report --audit $ dex import Downloads/*.csv $ dex pair ...","title":"Overview"},{"location":"dex_install/#virtual-environment","text":"Dexter depends on a several third-party libraries. We recommend setting up a new virtual environment for Dexter and its dependences. Start by choosing a Python version. Dexter requires Python 3.13 or higher: $ pyenv shell 3.13.1 Make a new environment based on the selected Python. You can name it anything; this example makes an environment named dexter : $ pyenv virtualenv dexter Run pip to download and install Dexter: $ pip install git+https://github.com/conery/dexter.git","title":"Virtual Environment"},{"location":"dex_install/#help-messages","text":"To test the installation ask dex to print a help message. If you run dex with no arguments you'll see an abbreviated help message: $ dex usage: dex [-h] [--dbname X] [--log X] [--preview] [--config F] {config,init,import,...} Use -h or --help to see a longer message: $ dex -h usage: dex [-h] [--dbname X] [--log X] [--preview] [--config F] {config,init,import,...} options: -h, --help show this help message and exit --dbname X database name --log X --preview --config F TOML file with configuration settings subcommands: config print default config file init initialize a database import add new records from files ... To print the help message for a subcommand, type the command name before typing -h or --help , e.g. $ dex init --help usage: dex init [-h] --file F options: -h, --help show this help message and exit --file F name of file with account definitions","title":"Help Messages"},{"location":"dex_pair/","text":"dex pair Usage $ dex pair --help usage: dex pair [-h] options: -h, --help show this help message and exit When postings created by importing financial transactions are saved by the import command Dexter tags the new postings with an #unpaired tag. The pair command fetches all of the unpaired postings and tries to find matches for them, as described in Pair Entries . two parts of a transfer can be paired to form a new transaction, using one part as the credit and the other as the debit it a posting matches a regular expression Dexter can create a new posting and form a new transaction with both postings. The only command line options are the general options for all commands. For example, to run pair in preview mode to have it print a description of the new transactions instead of adding them to the database: $ dex --preview pair","title":"dex pair"},{"location":"dex_pair/#dex-pair","text":"","title":"dex pair"},{"location":"dex_pair/#usage","text":"$ dex pair --help usage: dex pair [-h] options: -h, --help show this help message and exit When postings created by importing financial transactions are saved by the import command Dexter tags the new postings with an #unpaired tag. The pair command fetches all of the unpaired postings and tries to find matches for them, as described in Pair Entries . two parts of a transfer can be paired to form a new transaction, using one part as the credit and the other as the debit it a posting matches a regular expression Dexter can create a new posting and form a new transaction with both postings. The only command line options are the general options for all commands. For example, to run pair in preview mode to have it print a description of the new transactions instead of adding them to the database: $ dex --preview pair","title":"Usage"},{"location":"dex_report/","text":"dex report Usage $ dex report --help usage: dex report [-h] [--start_date D] [--end_date D] [--month M] [--no_budget] [--abbrev] [--grouped] [A ...] positional arguments: A accounts options: -h, --help show this help message and exit --start_date D starting date --end_date D ending date --month M define start and end dates based on month name --no_budget remove budget transactions --abbrev print abbreviated names --grouped group by account name","title":"dex report"},{"location":"dex_report/#dex-report","text":"","title":"dex report"},{"location":"dex_report/#usage","text":"$ dex report --help usage: dex report [-h] [--start_date D] [--end_date D] [--month M] [--no_budget] [--abbrev] [--grouped] [A ...] positional arguments: A accounts options: -h, --help show this help message and exit --start_date D starting date --end_date D ending date --month M define start and end dates based on month name --no_budget remove budget transactions --abbrev print abbreviated names --grouped group by account name","title":"Usage"},{"location":"dex_restore/","text":"dex restore Usage dex restore --help usage: dex restore [-h] [--force] F positional arguments: F name of file with records to restore options: -h, --help show this help message and exit --force replace an existing database","title":"dex restore"},{"location":"dex_restore/#dex-restore","text":"","title":"dex restore"},{"location":"dex_restore/#usage","text":"dex restore --help usage: dex restore [-h] [--force] F positional arguments: F name of file with records to restore options: -h, --help show this help message and exit --force replace an existing database","title":"Usage"},{"location":"dex_review/","text":"dex review Usage $ dex review --help usage: dex review [-h] [--fill_mode N] options: -h, --help show this help message and exit The review command uses a command line interface to display unpaired postings one at a time. The display shows the outline of a new transaction. Some of the fields will be filled in automatically using information from an unpaired posting. The rest must be supplied by the user to create a new posting, which is then combined with the existing posting to form a new transaction. The only option is --fill_mode , which tells Dexter how to initialize the description field in the transaction. The argument is a number between 0 and 2: 0 means \"leave the field blank\". It will be displayed in the template as the \"description\", in italics, as a placeholder to remind users to fill it in. 1 means \"copy the description from the posting\". 2 means \"copy the posting description and apply regular expressions\". The modes (and how they can be useful) are described in Review Unpaired Entries . Editing Operations All operations at initiated by a single keystroke, as shown in the tables below. The notation \u2303X is short for \"control-X\", i.e. hold down the control key when typing X. Navigation If you want to skip a transaction you can hit the down or up arrow to move to the next or previous transaction. Dexter exits the loop after the last unpaired posting has been paired. To exit before then type either \u2303C or \u2303D. The next time you run dex review Dexter will resume where you left off. keystroke operation comment \u2191 move to previous transaction \u2193 move to next transaction \u2303C exit \u2303D exit Field Selection keystroke operation comment \u2303P edit the description field mnemonic: \"p\" is for \"payee\" \u2303N edit the comment field mnemonic: \"n\" is for \"note\" \u2303G edit the tags field \u2303T edit the account field mnemonic: \"t\" is for \"to\" Command Line Editing TBD","title":"dex review"},{"location":"dex_review/#dex-review","text":"","title":"dex review"},{"location":"dex_review/#usage","text":"$ dex review --help usage: dex review [-h] [--fill_mode N] options: -h, --help show this help message and exit The review command uses a command line interface to display unpaired postings one at a time. The display shows the outline of a new transaction. Some of the fields will be filled in automatically using information from an unpaired posting. The rest must be supplied by the user to create a new posting, which is then combined with the existing posting to form a new transaction. The only option is --fill_mode , which tells Dexter how to initialize the description field in the transaction. The argument is a number between 0 and 2: 0 means \"leave the field blank\". It will be displayed in the template as the \"description\", in italics, as a placeholder to remind users to fill it in. 1 means \"copy the description from the posting\". 2 means \"copy the posting description and apply regular expressions\". The modes (and how they can be useful) are described in Review Unpaired Entries .","title":"Usage"},{"location":"dex_review/#editing-operations","text":"All operations at initiated by a single keystroke, as shown in the tables below. The notation \u2303X is short for \"control-X\", i.e. hold down the control key when typing X.","title":"Editing Operations"},{"location":"dex_review/#navigation","text":"If you want to skip a transaction you can hit the down or up arrow to move to the next or previous transaction. Dexter exits the loop after the last unpaired posting has been paired. To exit before then type either \u2303C or \u2303D. The next time you run dex review Dexter will resume where you left off. keystroke operation comment \u2191 move to previous transaction \u2193 move to next transaction \u2303C exit \u2303D exit","title":"Navigation"},{"location":"dex_review/#field-selection","text":"keystroke operation comment \u2303P edit the description field mnemonic: \"p\" is for \"payee\" \u2303N edit the comment field mnemonic: \"n\" is for \"note\" \u2303G edit the tags field \u2303T edit the account field mnemonic: \"t\" is for \"to\"","title":"Field Selection"},{"location":"dex_review/#command-line-editing","text":"TBD","title":"Command Line Editing"},{"location":"dex_save/","text":"dex save Usage $ dex save --help usage: dex save [-h] [--force] F positional arguments: F name of output file options: -h, --help show this help message and exit --force overwrite existing file","title":"dex save"},{"location":"dex_save/#dex-save","text":"","title":"dex save"},{"location":"dex_save/#usage","text":"$ dex save --help usage: dex save [-h] [--force] F positional arguments: F name of output file options: -h, --help show this help message and exit --force overwrite existing file","title":"Usage"},{"location":"dex_select/","text":"dex select Usage $ dex select --help usage: dex select [-h] [--entry] [--date D] [--start_date D] [--end_date D] [--month M] [--credit A] [--debit A] [--account A] [--column C] [--description X] [--comment X] [--tag X] [--amount N] [--min_amount N] [--max_amount N] [--abbrev] [--order_by C] [--total] [--update F V F V] [--journal | --csv] options: -h, --help show this help message and exit --entry seach individual debit or credit entries --date D transaction date --start_date D starting date --end_date D ending date --month M define start and end dates based on month name --credit A credit account name (transaction) --debit A debit account name (transaction) --account A account name (entry) --column C entry type (entry) --description X descriptions pattern --comment X comment pattern (transaction) --tag X tag pattern (transaction) --amount N amount --min_amount N minimum amount --max_amount N maximum amount --abbrev print abbreviated account names --order_by C sort order --total print total amount of selected transactions --update F V F V update fields --journal print in Journal format --csv print in CSV format, with a header line","title":"dex select"},{"location":"dex_select/#dex-select","text":"","title":"dex select"},{"location":"dex_select/#usage","text":"$ dex select --help usage: dex select [-h] [--entry] [--date D] [--start_date D] [--end_date D] [--month M] [--credit A] [--debit A] [--account A] [--column C] [--description X] [--comment X] [--tag X] [--amount N] [--min_amount N] [--max_amount N] [--abbrev] [--order_by C] [--total] [--update F V F V] [--journal | --csv] options: -h, --help show this help message and exit --entry seach individual debit or credit entries --date D transaction date --start_date D starting date --end_date D ending date --month M define start and end dates based on month name --credit A credit account name (transaction) --debit A debit account name (transaction) --account A account name (entry) --column C entry type (entry) --description X descriptions pattern --comment X comment pattern (transaction) --tag X tag pattern (transaction) --amount N amount --min_amount N minimum amount --max_amount N maximum amount --abbrev print abbreviated account names --order_by C sort order --total print total amount of selected transactions --update F V F V update fields --journal print in Journal format --csv print in CSV format, with a header line","title":"Usage"},{"location":"envelopes/","text":"Envelope Budgeting Dexter not only keeps track of expenses, it also helps users who want to try to control their expenses by maintaining a budget. The strategy we use is a familiar method called Envelope Budgeting. The idea is that when we get paid we should put money into envelopes with labels like \"groceries\", \"entertainment\", etc ,. When we make a purchase, the money should come from one of those envelopes. If we want to go to a baseball game but the entertainment envelope is empty it means we've already spent all the money we put aside for entertainment and should make other plans. Putting cash in physical envelopes is apparently still a thing ( Envelope Budgeting: Simple Cash Control ) but of course when we use Dexter we're going to set up virtual envelopes. But it's not obvious how to do this. Real cash-filled envelopes are, like checking accounts, assets. The intuitive approach would be to set up an additional set of asset accounts in our expense tracking system. Some personal finance applications allow users to create virtual accounts to use for budgeting (or other uses). But then each time an expense occurs we have to add a virtual transaction to update the envelopes. The approach we use in Dexter seems paradoxical, but in fact it makes a lot of sense, and as we'll see it is also far simpler to manage. The key idea: In Dexter envelopes are expense accounts. Our envelopes are not asset accounts, they are expense accounts. In fact, with Dexter, every expense account automatically becomes the envelope for that expense category. The question then becomes, \"how do we allocate money to envelopes?\" The short answer is \"by crediting the account.\" To see why that might be the case, consider these two transactions. The first is a purchase at a hardware store: 2024-04-21 Jerrys Home Improvement ; drill, screwdriver set visa \u2212$50.00 household $50.00 Now suppose a few days later we decide to return one of the things we bought. This leads to a new transaction: 2024-04-22 Jerrys Home Improvement ; we have enough screwdrivers household \u2212$20.00 visa $20.00 Notice how the role of the two accounts is the opposite: the original purchase has a debit to the expense account, but the return has a credit to that same account. In double-entry bookkeeping: a purchase debits an expense account, increasing its balance a return credits the account, decreasing its balance So the long answer to \"how do we fill envelopes?\" is that we add a new transaction at the start of each month that credits each of the expense categories: 2024-04-01 Fill envelopes groceries \u2212$200.00 household \u2212$500.00 entertainment \u2212$100.00 ... If each account starts out at $0 initially, that transaction sets the balance to a negative value. Now each purchase is going to add to the balance, and as more purchases are made the balance gets closer and closer to $0. When the balance hits $0 all the money has been spent from the envelope. To get back to the hardware store example: the envelope was \"filled\" with -$500 on Apr 1 the purchase on Apr 21 \"removed\" $50, so the updated balance is -$450 the return on Apr 22 \"put back\" $20 by crediting the account, updating the balance to -$470. But transactions need to be balanced, so now we have a new question: \"where is all that money in the envelope fillig transaction coming from?\" That also has a short answer: income accounts. The last line in the envelope-filling transaction is a debit to the source of income that we're putting in envelopes: income:salary $5000.00 That also seems very unlikely. Normally when an income account is used in a posting it's in a transaction that records salary or other income: 2024-04-22 Yoyodyne checking $5,000.00 income:salary \u2212$5,000.00 So now we have a new interpretation for the balance of an income account: when funds are transferred in to one of our asset accounts (like a deposit to our checking account) the balance of the income account decreases. As we allocate money to envelopes the balance increases. In fact, if it reaches $0 we can be sure that all of our income has been \"given a job\" and has been put in an envelope. Earlier the claim was made that Dexter's budgeting method was made far simpler by using expense accounts for envelopes. Now we can see why: the only transaction that needs to be added to manage envelopes is the one that fills the envelopes at the beginning of the month. After that, every transaction automatically updates the envelope. if we use a credit card to buy dinner at a restaurant, the debit to the restaurant account increases the balance (takes money from the envelope) if we use Venmo to send money to a friend, and Venmo takes that money from our checking account, that transaction will also debit restaurant , and again takes money from the same envelope if our employer deposits money in our checking account as a reimbursement for a dinner, that transaction can credit restaurant , putting money back in the envelope There is a lot to digest here, even for (maybe especially for) readers who are already familiar with double-entry bookkeeping. An entire section of this documentation is devoted to Dexter's approach to budgeting ( Envelope Budgeting with Dexter ). For now, these are the main ponts to take away from this short introduction: expense accounts can be used as virtual envelopes for money to use for the correponding expense category an envelope is \"filled\" by a tranaction that sets the account balance to a negative number a transaction that debits an expense account removes money from the envelope by increasing the balance, which moves it closer to $0 when the balance goes over $0 it means the sum of all purchases exceeds the amount put in the envelope","title":"Envelope Budgeting"},{"location":"envelopes/#envelope-budgeting","text":"Dexter not only keeps track of expenses, it also helps users who want to try to control their expenses by maintaining a budget. The strategy we use is a familiar method called Envelope Budgeting. The idea is that when we get paid we should put money into envelopes with labels like \"groceries\", \"entertainment\", etc ,. When we make a purchase, the money should come from one of those envelopes. If we want to go to a baseball game but the entertainment envelope is empty it means we've already spent all the money we put aside for entertainment and should make other plans. Putting cash in physical envelopes is apparently still a thing ( Envelope Budgeting: Simple Cash Control ) but of course when we use Dexter we're going to set up virtual envelopes. But it's not obvious how to do this. Real cash-filled envelopes are, like checking accounts, assets. The intuitive approach would be to set up an additional set of asset accounts in our expense tracking system. Some personal finance applications allow users to create virtual accounts to use for budgeting (or other uses). But then each time an expense occurs we have to add a virtual transaction to update the envelopes. The approach we use in Dexter seems paradoxical, but in fact it makes a lot of sense, and as we'll see it is also far simpler to manage. The key idea: In Dexter envelopes are expense accounts. Our envelopes are not asset accounts, they are expense accounts. In fact, with Dexter, every expense account automatically becomes the envelope for that expense category. The question then becomes, \"how do we allocate money to envelopes?\" The short answer is \"by crediting the account.\" To see why that might be the case, consider these two transactions. The first is a purchase at a hardware store: 2024-04-21 Jerrys Home Improvement ; drill, screwdriver set visa \u2212$50.00 household $50.00 Now suppose a few days later we decide to return one of the things we bought. This leads to a new transaction: 2024-04-22 Jerrys Home Improvement ; we have enough screwdrivers household \u2212$20.00 visa $20.00 Notice how the role of the two accounts is the opposite: the original purchase has a debit to the expense account, but the return has a credit to that same account. In double-entry bookkeeping: a purchase debits an expense account, increasing its balance a return credits the account, decreasing its balance So the long answer to \"how do we fill envelopes?\" is that we add a new transaction at the start of each month that credits each of the expense categories: 2024-04-01 Fill envelopes groceries \u2212$200.00 household \u2212$500.00 entertainment \u2212$100.00 ... If each account starts out at $0 initially, that transaction sets the balance to a negative value. Now each purchase is going to add to the balance, and as more purchases are made the balance gets closer and closer to $0. When the balance hits $0 all the money has been spent from the envelope. To get back to the hardware store example: the envelope was \"filled\" with -$500 on Apr 1 the purchase on Apr 21 \"removed\" $50, so the updated balance is -$450 the return on Apr 22 \"put back\" $20 by crediting the account, updating the balance to -$470. But transactions need to be balanced, so now we have a new question: \"where is all that money in the envelope fillig transaction coming from?\" That also has a short answer: income accounts. The last line in the envelope-filling transaction is a debit to the source of income that we're putting in envelopes: income:salary $5000.00 That also seems very unlikely. Normally when an income account is used in a posting it's in a transaction that records salary or other income: 2024-04-22 Yoyodyne checking $5,000.00 income:salary \u2212$5,000.00 So now we have a new interpretation for the balance of an income account: when funds are transferred in to one of our asset accounts (like a deposit to our checking account) the balance of the income account decreases. As we allocate money to envelopes the balance increases. In fact, if it reaches $0 we can be sure that all of our income has been \"given a job\" and has been put in an envelope. Earlier the claim was made that Dexter's budgeting method was made far simpler by using expense accounts for envelopes. Now we can see why: the only transaction that needs to be added to manage envelopes is the one that fills the envelopes at the beginning of the month. After that, every transaction automatically updates the envelope. if we use a credit card to buy dinner at a restaurant, the debit to the restaurant account increases the balance (takes money from the envelope) if we use Venmo to send money to a friend, and Venmo takes that money from our checking account, that transaction will also debit restaurant , and again takes money from the same envelope if our employer deposits money in our checking account as a reimbursement for a dinner, that transaction can credit restaurant , putting money back in the envelope There is a lot to digest here, even for (maybe especially for) readers who are already familiar with double-entry bookkeeping. An entire section of this documentation is devoted to Dexter's approach to budgeting ( Envelope Budgeting with Dexter ). For now, these are the main ponts to take away from this short introduction: expense accounts can be used as virtual envelopes for money to use for the correponding expense category an envelope is \"filled\" by a tranaction that sets the account balance to a negative number a transaction that debits an expense account removes money from the envelope by increasing the balance, which moves it closer to $0 when the balance goes over $0 it means the sum of all purchases exceeds the amount put in the envelope","title":"Envelope Budgeting"},{"location":"envelopes_dex/","text":"Envelope Budgeting with Dexter Envelope budgeting is a systen where income is allocated to \"envelopes\" or \"buckets\" for different expense categories. When an expense is incurred, it should be paid for out of the corresponding envelope. It is a very old and time-tested strategy and still very popular ( The Envelope Budgeting Method: Does It Still Work? ) The idea is that when we go to make a purchase and there is not enough money in an envelope we should rethink our plans. If the envelope labeled \"restaurants\" has only $20 and there are still two weeks before the next budget period we should probably not go out to that fancy new restaurant tonight. A related method, known as zero-based budgeting, suggests users allocate all of their income to envelopes. To use a phrase from YNAB , the goal is to \"give every dollar a job.\" The budgeting process should help users take the long view by allowing funds in an envelope to roll over to next period. If we know we're going to need new tires for the car some time in the next year we should start adding an extra $100 to the car envelope every month so it will be there when we need it. Of course, we're not taping real envelopes to our refrigerators. Our envelopes are managed by our personal finance software and have a lot more flexibility. For one thing, we can allow a negative balance. If we only have $400 in the car expense envelope but can't delay the tire purchase and need to pay $600 this month it's not a problem. The car envelope will drop to -$200, but we know it will build back up in the coming months. Integrating envelope budgeting with double-entry bookkeeping is not simple. Several people have shared their envelope budget process on the discussion boards for GnuCash and plain text accounting applications ( Budgeting - plaintextaccounting.org ). These typically involve setting up new asset accounts to represent envelopes and virtual transactions to coordinate expenses and envelopes. Our method is much simpler. We don't require any new accounts or any type of virtual transactions. A single budget allocation transaction at the beginning of the month will fill envelopes, and after that all purchases automatically reduce the available funds in the corresponding envelope. Although our approach is simpler, budget transactions have a very unusual form: they debit expense accounts and credit debit accounts. The remainder of this part of the documentation is a deep dive into how and why this approach works: the first section is a review of how account balances are computed the next section defines budget transactions in more detail following that are discussions of how budget transactions affect the balances of income and expense accounts the section on \"adjustments\" shows how to move money between envelopes the equity account can be used in unusual situations, such as dipping into savings to fund a special trip","title":"Envelope Budgeting with Dexter"},{"location":"envelopes_dex/#envelope-budgeting-with-dexter","text":"Envelope budgeting is a systen where income is allocated to \"envelopes\" or \"buckets\" for different expense categories. When an expense is incurred, it should be paid for out of the corresponding envelope. It is a very old and time-tested strategy and still very popular ( The Envelope Budgeting Method: Does It Still Work? ) The idea is that when we go to make a purchase and there is not enough money in an envelope we should rethink our plans. If the envelope labeled \"restaurants\" has only $20 and there are still two weeks before the next budget period we should probably not go out to that fancy new restaurant tonight. A related method, known as zero-based budgeting, suggests users allocate all of their income to envelopes. To use a phrase from YNAB , the goal is to \"give every dollar a job.\" The budgeting process should help users take the long view by allowing funds in an envelope to roll over to next period. If we know we're going to need new tires for the car some time in the next year we should start adding an extra $100 to the car envelope every month so it will be there when we need it. Of course, we're not taping real envelopes to our refrigerators. Our envelopes are managed by our personal finance software and have a lot more flexibility. For one thing, we can allow a negative balance. If we only have $400 in the car expense envelope but can't delay the tire purchase and need to pay $600 this month it's not a problem. The car envelope will drop to -$200, but we know it will build back up in the coming months. Integrating envelope budgeting with double-entry bookkeeping is not simple. Several people have shared their envelope budget process on the discussion boards for GnuCash and plain text accounting applications ( Budgeting - plaintextaccounting.org ). These typically involve setting up new asset accounts to represent envelopes and virtual transactions to coordinate expenses and envelopes. Our method is much simpler. We don't require any new accounts or any type of virtual transactions. A single budget allocation transaction at the beginning of the month will fill envelopes, and after that all purchases automatically reduce the available funds in the corresponding envelope. Although our approach is simpler, budget transactions have a very unusual form: they debit expense accounts and credit debit accounts. The remainder of this part of the documentation is a deep dive into how and why this approach works: the first section is a review of how account balances are computed the next section defines budget transactions in more detail following that are discussions of how budget transactions affect the balances of income and expense accounts the section on \"adjustments\" shows how to move money between envelopes the equity account can be used in unusual situations, such as dipping into savings to fund a special trip","title":"Envelope Budgeting with Dexter"},{"location":"equity/","text":"Using the Equity Account When a database is initialized we define initial balances for the asset accounts using transactions that debit the asset and credit a special account named equity . Several accounts can be initialized with a single transaction. This shows our checking account had $1000 and our savings account had $7000 on January 1: 2024-01-01 initial balances assets:checking $1000.00 assets:savings $7000.00 equity $-8000.00 To make sure the transaction balances, the amount on the last line is the total amount in all of our accounts. Transfers to Savings Accounts We can use the equity account to model situations where we want to set aside a part of our income for long term savings. Suppose we want to save $500 every month. If we actually transfer that much from our checking account to our savings account the database will have a transaction that records the transfer: 2024-01-01 monthly saving assets:savings $500.00 assets:checking $-500.00 This transfer involves two assets, but it doesn't say anything about the monthly budget. We still need a way to record the fact that part of our income is being allocated to envelopes to use for expenses and part is going to long term savings. That's where the equity account comes into play. Simply add a credit to the budget transaction that shows the amount that was transferred to savings: 2024-01-02 fill envelopes ; budget: income:yoyodyne $5000.00 expenses:home $-2500.00 expenses:car $-1000.00 expenses:food $-1000.00 equity: $-500.00 ; transferred to savings Note that we've updated the budget, changing the home expenses from $3000 to $2500 to make room for the savings transfer. The equity line in the budget transactions serves two purposes: It makes sure the transaction is balanced, so we can still be sure every dollar has a job. It increases the balance of the equity account, just the way the credit in the transaction that initialized the account balances did. So basically we're saying our equity has gone up by $500, which is consistent with the fact that we've added $500 to savings. Transfers from Savings Accounts The previous section showed how to credit the equity account when transferring income to a savings account. We can do the same thing, but in reverse, when we move money out of savings. Suppose one of our savings accounts was earmarked for a trip to France and now we're ready to go. We want to move money to our checking account so it can be used, either through direct purchases from checking or to eventually pay off credit card purchases. There will be a transfer between the two accounts: 2024-03-15 going to France! assets:checking $3000.00 assets:savings $-3000.00 But we also want to make sure that money ends up in the travel envelope: 2024-03-15 France savings to travel envelope ; budget: equity: $3000.00 expenses:travel $-3000.00 Note how we're debiting equity (when we moved money to savings it was a credit), and the credit to the expense account is adding the money to the travel envelope (just like the credits in the budget transaction). Important: This transaction should also be tagged so it is filtered out with other budget transactions when making reports that use the standard definitions of income and expense balance.","title":"Using the Equity Account"},{"location":"equity/#using-the-equity-account","text":"When a database is initialized we define initial balances for the asset accounts using transactions that debit the asset and credit a special account named equity . Several accounts can be initialized with a single transaction. This shows our checking account had $1000 and our savings account had $7000 on January 1: 2024-01-01 initial balances assets:checking $1000.00 assets:savings $7000.00 equity $-8000.00 To make sure the transaction balances, the amount on the last line is the total amount in all of our accounts.","title":"Using the Equity Account"},{"location":"equity/#transfers-to-savings-accounts","text":"We can use the equity account to model situations where we want to set aside a part of our income for long term savings. Suppose we want to save $500 every month. If we actually transfer that much from our checking account to our savings account the database will have a transaction that records the transfer: 2024-01-01 monthly saving assets:savings $500.00 assets:checking $-500.00 This transfer involves two assets, but it doesn't say anything about the monthly budget. We still need a way to record the fact that part of our income is being allocated to envelopes to use for expenses and part is going to long term savings. That's where the equity account comes into play. Simply add a credit to the budget transaction that shows the amount that was transferred to savings: 2024-01-02 fill envelopes ; budget: income:yoyodyne $5000.00 expenses:home $-2500.00 expenses:car $-1000.00 expenses:food $-1000.00 equity: $-500.00 ; transferred to savings Note that we've updated the budget, changing the home expenses from $3000 to $2500 to make room for the savings transfer. The equity line in the budget transactions serves two purposes: It makes sure the transaction is balanced, so we can still be sure every dollar has a job. It increases the balance of the equity account, just the way the credit in the transaction that initialized the account balances did. So basically we're saying our equity has gone up by $500, which is consistent with the fact that we've added $500 to savings.","title":"Transfers to Savings Accounts"},{"location":"equity/#transfers-from-savings-accounts","text":"The previous section showed how to credit the equity account when transferring income to a savings account. We can do the same thing, but in reverse, when we move money out of savings. Suppose one of our savings accounts was earmarked for a trip to France and now we're ready to go. We want to move money to our checking account so it can be used, either through direct purchases from checking or to eventually pay off credit card purchases. There will be a transfer between the two accounts: 2024-03-15 going to France! assets:checking $3000.00 assets:savings $-3000.00 But we also want to make sure that money ends up in the travel envelope: 2024-03-15 France savings to travel envelope ; budget: equity: $3000.00 expenses:travel $-3000.00 Note how we're debiting equity (when we moved money to savings it was a credit), and the credit to the expense account is adding the money to the travel envelope (just like the credits in the budget transaction). Important: This transaction should also be tagged so it is filtered out with other budget transactions when making reports that use the standard definitions of income and expense balance.","title":"Transfers from Savings Accounts"},{"location":"fill_date/","text":"Fill date TBD","title":"Fill Date"},{"location":"fill_date/#fill-date","text":"TBD","title":"Fill date"},{"location":"folder/","text":"Create Your Project Directory The example data for this tutorial is in an archive that can be downloaded from the GitHub repo: URL When you expand the archive you will have a new directory named Finances with the following structure: Finances/ \u251c\u2500\u2500 accounts.csv -- account names used to initialize the database \u251c\u2500\u2500 accounts.journal -- same, but in an alternate format \u251c\u2500\u2500 dex.toml -- Dexter configuration file \u251c\u2500\u2500 Downloads -- directory for CSV records from financial institutions \u2502 \u251c\u2500\u2500 apr \u2502 \u2514\u2500\u2500 may \u2514\u2500\u2500 regexp.csv -- regular expressions used by pair command We refer to this folder as a project directory . When you start working with your own data we recommend you create your own project directory with the same structure. The configuration file has some important information you will need to define. You will need only one account definition file. There are two here to show examples of the two formats Dexter recognizes. Regular expressions have patterns that help automatically assign expense categories when CSV files downloaded from banks and card companies are imported. The Downloads folder is where you will save those CSV files. Activate the Virtual Environment One of the main reasons for creating a project directory is so that you can easily activate the Python virtual environment where Dexter was installed. After you expand the archive, cd to the top level folder and type this command: $ pyenv local dexter Now whenever you cd to this folder the virtual environment will be activated automatically and you will be able to type shell commands that run Dexter. Example Data The account definitions and the sample CSV files are distilled from from real data. To keep things simple, there is one checking account, one savings account, one credit card, and only four budget categories (the complete list of accounts is shown below). The expense categories are diverse enough to be able to illustrate the budget model and how subaccounts work, but with only four categories it is not as complex as a real set of categories will be. The Downloads folder has two subfolders, named for months. The apr folder has hypothetical transactions for the three accounts for the month of April, 2024, and the may folder has the corresponding files for May, 2024. Accounts Here is a complete list of all the accounts used in the tutorial data. Category Full Name Abbreviated Name Assets assets:bank:checking checking assets:bank:savings savings Expenses expenses:car expenses:car:payment expenses:car:fuel fuel expenses:entertainment entertainment expenses:food expenses:food:groceries groceries expenses:food:restaurant restaurant expenses:home expenses:home:mortgage mortgage expenses:home:household household expenses:home:utility utility expenses:home:yard yard Income income:yoyodyne income:interest Liabilities liabilities:chase:visa visa","title":"Create Your Project Directory"},{"location":"folder/#create-your-project-directory","text":"The example data for this tutorial is in an archive that can be downloaded from the GitHub repo: URL When you expand the archive you will have a new directory named Finances with the following structure: Finances/ \u251c\u2500\u2500 accounts.csv -- account names used to initialize the database \u251c\u2500\u2500 accounts.journal -- same, but in an alternate format \u251c\u2500\u2500 dex.toml -- Dexter configuration file \u251c\u2500\u2500 Downloads -- directory for CSV records from financial institutions \u2502 \u251c\u2500\u2500 apr \u2502 \u2514\u2500\u2500 may \u2514\u2500\u2500 regexp.csv -- regular expressions used by pair command We refer to this folder as a project directory . When you start working with your own data we recommend you create your own project directory with the same structure. The configuration file has some important information you will need to define. You will need only one account definition file. There are two here to show examples of the two formats Dexter recognizes. Regular expressions have patterns that help automatically assign expense categories when CSV files downloaded from banks and card companies are imported. The Downloads folder is where you will save those CSV files.","title":"Create Your Project Directory"},{"location":"folder/#activate-the-virtual-environment","text":"One of the main reasons for creating a project directory is so that you can easily activate the Python virtual environment where Dexter was installed. After you expand the archive, cd to the top level folder and type this command: $ pyenv local dexter Now whenever you cd to this folder the virtual environment will be activated automatically and you will be able to type shell commands that run Dexter.","title":"Activate the Virtual Environment"},{"location":"folder/#example-data","text":"The account definitions and the sample CSV files are distilled from from real data. To keep things simple, there is one checking account, one savings account, one credit card, and only four budget categories (the complete list of accounts is shown below). The expense categories are diverse enough to be able to illustrate the budget model and how subaccounts work, but with only four categories it is not as complex as a real set of categories will be. The Downloads folder has two subfolders, named for months. The apr folder has hypothetical transactions for the three accounts for the month of April, 2024, and the may folder has the corresponding files for May, 2024.","title":"Example Data"},{"location":"folder/#accounts","text":"Here is a complete list of all the accounts used in the tutorial data. Category Full Name Abbreviated Name Assets assets:bank:checking checking assets:bank:savings savings Expenses expenses:car expenses:car:payment expenses:car:fuel fuel expenses:entertainment entertainment expenses:food expenses:food:groceries groceries expenses:food:restaurant restaurant expenses:home expenses:home:mortgage mortgage expenses:home:household household expenses:home:utility utility expenses:home:yard yard Income income:yoyodyne income:interest Liabilities liabilities:chase:visa visa","title":"Accounts"},{"location":"history/","text":"History The Evolution of Dexter The first program I wrote to keep track of personal expenses was written in Pascal and ran on an operating system named CPM. OK, that's too much history. Fast forward: after trying several commercial programs and writing my own GUI applications I've come back full circle to a command line API. My current workflow uses a set of Python scripts that save transactions in a SQLite database. I moved away from a monolithic GUI because independent scripts are more effective if each one can focus on its part of the workflow. Using the command line means I can take advantage of command history, completions, and other features. The GitHub repo has a rewrite of my current scripts. My goals were to transition from SQLite to a NoSQL database (mongodb) clean up and document each script create a more extensive set of unit tests As of May 2025 the scripts in the repo are sufficient to carry out the main steps in my monthly bill-paying workflow. There are bound to be errors and incomplete sections, so the software is still in pre-release (beta). Current Status (May 2025) The modules currently in the repo are sufficent to run all the examples described in the tutorial section, starting with Create Your Project Directory . As you work through the tutorial you will: initialize a new database using account specifications in example files add records from CSV files downloaded from financial institutions use regular expressions to form transactions based on pairs of debit and credit entries use a specialized command line interface to process records that were not paired automatically run report generators to print account balances and expense transactions","title":"History"},{"location":"history/#history","text":"","title":"History"},{"location":"history/#the-evolution-of-dexter","text":"The first program I wrote to keep track of personal expenses was written in Pascal and ran on an operating system named CPM. OK, that's too much history. Fast forward: after trying several commercial programs and writing my own GUI applications I've come back full circle to a command line API. My current workflow uses a set of Python scripts that save transactions in a SQLite database. I moved away from a monolithic GUI because independent scripts are more effective if each one can focus on its part of the workflow. Using the command line means I can take advantage of command history, completions, and other features. The GitHub repo has a rewrite of my current scripts. My goals were to transition from SQLite to a NoSQL database (mongodb) clean up and document each script create a more extensive set of unit tests As of May 2025 the scripts in the repo are sufficient to carry out the main steps in my monthly bill-paying workflow. There are bound to be errors and incomplete sections, so the software is still in pre-release (beta).","title":"The Evolution of Dexter"},{"location":"history/#current-status-may-2025","text":"The modules currently in the repo are sufficent to run all the examples described in the tutorial section, starting with Create Your Project Directory . As you work through the tutorial you will: initialize a new database using account specifications in example files add records from CSV files downloaded from financial institutions use regular expressions to form transactions based on pairs of debit and credit entries use a specialized command line interface to process records that were not paired automatically run report generators to print account balances and expense transactions","title":"Current Status (May 2025)"},{"location":"hledger/","text":"hledger Workflow Dexter stores account data and transactions in a NoSQL database, so it's not strictly a plain text accounting application, but it does support the .journal format used by Ledger, hledger, and similar applications. It's a straightforward process to import a journal with account definitions to initialize a database, use Dexter's workflow to process a batch of CSV files downloaded from banks and credit card companies, and export the results as a journal file. More to come...","title":"Notes for hledger Users"},{"location":"hledger/#hledger-workflow","text":"Dexter stores account data and transactions in a NoSQL database, so it's not strictly a plain text accounting application, but it does support the .journal format used by Ledger, hledger, and similar applications. It's a straightforward process to import a journal with account definitions to initialize a database, use Dexter's workflow to process a batch of CSV files downloaded from banks and credit card companies, and export the results as a journal file. More to come...","title":"hledger Workflow"},{"location":"modules/","text":"Dexter Section TBD...","title":"Modules"},{"location":"modules/#dexter","text":"Section TBD...","title":"Dexter"},{"location":"nominal/","text":"Nominal Accounts The literature on double-entry bookkeeping distinguishes between two types of accounts. Assets and liabilities are real accounts . They have counterparts that exist in the real world, outside your accounting system. They are things like checking and savings accounts at a bank, mortgages and car loans, or credit card accounts. When we download a CSV file from a financial institution the records in the file become debits or credits to real accounts in our database. Income and expenses are nominal accounts . These accounts do not have counterparts in the real world. Their role is to help us organize our transactions. We create these accounts to match our goals. As an example of why income is nominal, consider how we might classify a monthly paycheck. We could have just one account named income . But if we have multiple sources of income -- two jobs, or a side gig selling crafts on Etsy -- it might be worthwhile distinguishing between them and having accounts with names like income:yoyodyne for paychecks (using the name of the company) and income:etsy for internet sales. Expenses are even more flexible. Do we have one general account named food ? Or do want to have different accounts for the different ways we spend money on food, e.g. groceries and restaurants ? Or maybe we could better track expenses if we had a hierarchy: food:groceries , food:restaurants , food:snacks , and so on? And what about food we buy when travelling? Do we have travel:meals along with the food accounts? The bottom line is that you create nominal accounts to best fit your goals for tracking your own personal finances. Budget Transactions Use Nominal Accounts It's worth pointing out that the budget transactions we discussed above -- allocating funds to envelopes and moving funds between envelopes -- involve only nominal accounts. A budget plan is based on your needs and your preferences. The decisions of which money to allocate and what the funds are to be used for are completely in your hands. It's only natural that the debit and credit accounts in budget transactions are all nominal accounts, which are also under your control.","title":"Nominal Accounts"},{"location":"nominal/#nominal-accounts","text":"The literature on double-entry bookkeeping distinguishes between two types of accounts. Assets and liabilities are real accounts . They have counterparts that exist in the real world, outside your accounting system. They are things like checking and savings accounts at a bank, mortgages and car loans, or credit card accounts. When we download a CSV file from a financial institution the records in the file become debits or credits to real accounts in our database. Income and expenses are nominal accounts . These accounts do not have counterparts in the real world. Their role is to help us organize our transactions. We create these accounts to match our goals. As an example of why income is nominal, consider how we might classify a monthly paycheck. We could have just one account named income . But if we have multiple sources of income -- two jobs, or a side gig selling crafts on Etsy -- it might be worthwhile distinguishing between them and having accounts with names like income:yoyodyne for paychecks (using the name of the company) and income:etsy for internet sales. Expenses are even more flexible. Do we have one general account named food ? Or do want to have different accounts for the different ways we spend money on food, e.g. groceries and restaurants ? Or maybe we could better track expenses if we had a hierarchy: food:groceries , food:restaurants , food:snacks , and so on? And what about food we buy when travelling? Do we have travel:meals along with the food accounts? The bottom line is that you create nominal accounts to best fit your goals for tracking your own personal finances.","title":"Nominal Accounts"},{"location":"nominal/#budget-transactions-use-nominal-accounts","text":"It's worth pointing out that the budget transactions we discussed above -- allocating funds to envelopes and moving funds between envelopes -- involve only nominal accounts. A budget plan is based on your needs and your preferences. The decisions of which money to allocate and what the funds are to be used for are completely in your hands. It's only natural that the debit and credit accounts in budget transactions are all nominal accounts, which are also under your control.","title":"Budget Transactions Use Nominal Accounts"},{"location":"options/","text":"Command Line Options There are two types of command line options: those that are common to all commands, and options that are specific to each command. Following a common Unix convention, option names can be abbreviated as long as they are distinct from other options. For example, the select command has options named debit and date . If you want to specify a value for debit you can use --debit or --deb or even --de , but not just --d because both \"debit\" and \"date\" start with \"d\". Common Options The first part of the main help message shows the names of the common options: options: -h, --help show this help message and exit --dbname X database name --log X --preview --config F TOML file with configuration settings Note: Common options must be typed before a subcommand name. dbname The name of the database to use. If no name is given, Dexter will look for an environment variable named DEX_DB . Example: initialize a new database named foo : $ dex --db foo init ... log This option controls the amount of information printed on the terminal. Alternatives are quiet (don't print anything), info (the default), and debug (which prints a ton of stuff, intended for developers who are tracking down problems). Example: initialize a new database but dont' print status messages. $ dex --db foo --log quiet init ... preview If this option is specified Dexter will print descriptions of data it will use but won't actually carry out the operation. As an example of how to use it, suppose you have downloaded a CSV file and saved it in Downloads/checking.csv and now you want to import it. If you want to see a list of the Postings that Dexter extracts from the file include the -preview option: $ dex --preview import Downloads/checking.csv To save the records in the database run the command again without --preview . config Dexter uses a configuration file to specify many different runtime options. By default it looks for a file named dex.toml in the current directory or a file name specified with the DEX_CONFIG enfironment variable. Use the config option to specify an alternative file. Subcommand Options If a subcommand has options they are specified after the command name. For example, the select command has options to speficy attributes of transactions to search for. These include the start and end dates, descriptions, amounts, and so on. This command searches the database named dev to find car expenses (transactions that debit the car account) with dates before Jan 31 2025: $ dex --db dev select --end 2025-01-31 --debit car Important: Notice how the --db option, which is common to all dex subcommands, comes before the command name, while the --end and --debit options for select are after the command name. Date Range Options Several subcommands have --start_date , --end_date , and --month options. For --start_date and --end_date you can specify dates with a variety of formats. If the format includes spaces or slashes make sure you put quotes around the date. All of these are ways of specifying an end date of Jan 31, 2025: --end_date 2025-01-31 --end_date 'Jan 31, 2025' --end_date '1/31/2025' --end_date '1/31' (for the last example, the year is inferred from the current date). If the day number is 12 or less a date is ambiguous. Is 1/7 Jan 7 or Jul 1? For dates with slashes Dexter uses the American convention that the month number precedes the day number. The --month option is a shorthand for specifying both a starting and ending date. The argument should be a 3-letter month abbreviation, from jan , feb , etc up to dec . Dexter will convert the month name into a pair of dates within the last year. Suppose today's date is May 5, 2025. If you specify --mon apr the start date will be Apr 1, 2025 and the end date Apr 30, 2025. If you specify --mon sep you will get a starting date of Sep 1, 2024 and an ending date of Sep 30, 2024.","title":"Command Line Options"},{"location":"options/#command-line-options","text":"There are two types of command line options: those that are common to all commands, and options that are specific to each command. Following a common Unix convention, option names can be abbreviated as long as they are distinct from other options. For example, the select command has options named debit and date . If you want to specify a value for debit you can use --debit or --deb or even --de , but not just --d because both \"debit\" and \"date\" start with \"d\".","title":"Command Line Options"},{"location":"options/#common-options","text":"The first part of the main help message shows the names of the common options: options: -h, --help show this help message and exit --dbname X database name --log X --preview --config F TOML file with configuration settings Note: Common options must be typed before a subcommand name.","title":"Common Options"},{"location":"options/#dbname","text":"The name of the database to use. If no name is given, Dexter will look for an environment variable named DEX_DB . Example: initialize a new database named foo : $ dex --db foo init ...","title":"dbname"},{"location":"options/#log","text":"This option controls the amount of information printed on the terminal. Alternatives are quiet (don't print anything), info (the default), and debug (which prints a ton of stuff, intended for developers who are tracking down problems). Example: initialize a new database but dont' print status messages. $ dex --db foo --log quiet init ...","title":"log"},{"location":"options/#preview","text":"If this option is specified Dexter will print descriptions of data it will use but won't actually carry out the operation. As an example of how to use it, suppose you have downloaded a CSV file and saved it in Downloads/checking.csv and now you want to import it. If you want to see a list of the Postings that Dexter extracts from the file include the -preview option: $ dex --preview import Downloads/checking.csv To save the records in the database run the command again without --preview .","title":"preview"},{"location":"options/#config","text":"Dexter uses a configuration file to specify many different runtime options. By default it looks for a file named dex.toml in the current directory or a file name specified with the DEX_CONFIG enfironment variable. Use the config option to specify an alternative file.","title":"config"},{"location":"options/#subcommand-options","text":"If a subcommand has options they are specified after the command name. For example, the select command has options to speficy attributes of transactions to search for. These include the start and end dates, descriptions, amounts, and so on. This command searches the database named dev to find car expenses (transactions that debit the car account) with dates before Jan 31 2025: $ dex --db dev select --end 2025-01-31 --debit car Important: Notice how the --db option, which is common to all dex subcommands, comes before the command name, while the --end and --debit options for select are after the command name.","title":"Subcommand Options"},{"location":"options/#date-range-options","text":"Several subcommands have --start_date , --end_date , and --month options. For --start_date and --end_date you can specify dates with a variety of formats. If the format includes spaces or slashes make sure you put quotes around the date. All of these are ways of specifying an end date of Jan 31, 2025: --end_date 2025-01-31 --end_date 'Jan 31, 2025' --end_date '1/31/2025' --end_date '1/31' (for the last example, the year is inferred from the current date). If the day number is 12 or less a date is ambiguous. Is 1/7 Jan 7 or Jul 1? For dates with slashes Dexter uses the American convention that the month number precedes the day number. The --month option is a shorthand for specifying both a starting and ending date. The argument should be a 3-letter month abbreviation, from jan , feb , etc up to dec . Dexter will convert the month name into a pair of dates within the last year. Suppose today's date is May 5, 2025. If you specify --mon apr the start date will be Apr 1, 2025 and the end date Apr 30, 2025. If you specify --mon sep you will get a starting date of Sep 1, 2024 and an ending date of Sep 30, 2024.","title":"Date Range Options"},{"location":"parsers/","text":"Parsers TBD A detailed discussion of how Dexter evaluates expressions on the right side of parser rules.","title":"Parsers"},{"location":"parsers/#parsers","text":"TBD A detailed discussion of how Dexter evaluates expressions on the right side of parser rules.","title":"Parsers"},{"location":"philosophy/","text":"Philosophy Our financial lives a more complex and varied since the 1980s, when I wrote that first Pascal program. Back then I had one checking account and a few credit cards, and it wasn't too hard to enter each transaction by hand when doing the bills each month. Nowdays we have a variety of ways to spend money. We still might write checks by hand, but are more likely to use our bank's online bill paying system. Whether you want to or not, you'll probably have several credit cards, not just for buying stuff (online or in person), but for making travel arrangements, paying for subscriptions and streaming services, and more. And then there are PayPal, Venmo, Apple Pay, and other \"e-cash\" systems. All of the organizations we deal with -- banks, card companies, and e-cash services -- allow us to download a record of our transactions. Why not take advantage of all that data? Dexter is designed for users who download all of their transactions. Given that premise as a starting point, Dexter has several core principles. Every CSV Record Becomes a Posting Every record in a CSV file downloaded from a financial institution is from a real world event. It needs to be turned into a posting that debits or credits one of our real accounts, i.e. either an asset or a liability account. Postings from CSVs Are Immutable When importing a CSV record we save the date, description, amount, and type (debit or credit) as part of the posting. This information is used to compute a unique ID for each posting (so records are not imported twice) and never changes after the posting is saved. Postings from CSVs Are Never Deleted Postings created from CSV files are a permanent record of real-world transactions. Postings Need to Be Paired to Form Transactions The CSV records by themselves are not complete transactions. They are merely building blocks, either a credit or a debit that must be matched with another posting to create a transaction. There are two ways to form transactions: Find two postings that are the source and destination of a transfer. These postings will have the same amount but different \"polarities\", i.e. one will be a credit and one will be a debit. Examples are transfers between bank accounts or credit card payments. Create a new complementary posting that debits or credits a nominal account. For example, if a posting is a credit to the checking account (and was not paired with another posting as part of a transfer) it is a check or debit card purchase. We need to figure out what the purchase was for and create a debit to an expense category. The next section is an overview of scripts that help streamline this process, e.g. by automatically create postings based on pattern matching.","title":"Philosophy"},{"location":"philosophy/#philosophy","text":"Our financial lives a more complex and varied since the 1980s, when I wrote that first Pascal program. Back then I had one checking account and a few credit cards, and it wasn't too hard to enter each transaction by hand when doing the bills each month. Nowdays we have a variety of ways to spend money. We still might write checks by hand, but are more likely to use our bank's online bill paying system. Whether you want to or not, you'll probably have several credit cards, not just for buying stuff (online or in person), but for making travel arrangements, paying for subscriptions and streaming services, and more. And then there are PayPal, Venmo, Apple Pay, and other \"e-cash\" systems. All of the organizations we deal with -- banks, card companies, and e-cash services -- allow us to download a record of our transactions. Why not take advantage of all that data? Dexter is designed for users who download all of their transactions. Given that premise as a starting point, Dexter has several core principles.","title":"Philosophy"},{"location":"philosophy/#every-csv-record-becomes-a-posting","text":"Every record in a CSV file downloaded from a financial institution is from a real world event. It needs to be turned into a posting that debits or credits one of our real accounts, i.e. either an asset or a liability account.","title":"Every CSV Record Becomes a Posting"},{"location":"philosophy/#postings-from-csvs-are-immutable","text":"When importing a CSV record we save the date, description, amount, and type (debit or credit) as part of the posting. This information is used to compute a unique ID for each posting (so records are not imported twice) and never changes after the posting is saved.","title":"Postings from CSVs Are Immutable"},{"location":"philosophy/#postings-from-csvs-are-never-deleted","text":"Postings created from CSV files are a permanent record of real-world transactions.","title":"Postings from CSVs Are Never Deleted"},{"location":"philosophy/#postings-need-to-be-paired-to-form-transactions","text":"The CSV records by themselves are not complete transactions. They are merely building blocks, either a credit or a debit that must be matched with another posting to create a transaction. There are two ways to form transactions: Find two postings that are the source and destination of a transfer. These postings will have the same amount but different \"polarities\", i.e. one will be a credit and one will be a debit. Examples are transfers between bank accounts or credit card payments. Create a new complementary posting that debits or credits a nominal account. For example, if a posting is a credit to the checking account (and was not paired with another posting as part of a transfer) it is a check or debit card purchase. We need to figure out what the purchase was for and create a debit to an expense category. The next section is an overview of scripts that help streamline this process, e.g. by automatically create postings based on pattern matching.","title":"Postings Need to Be Paired to Form Transactions"},{"location":"recap/","text":"Recap Envelope Budgeting in Dexter Envelopes are expense accounts, not assets. When a budget transaction fills envelopes it credits expense accounts and debits income accounts . A transaction that debits an expense account automatically uses funds from that envelope; no additional transactions are required. The balance of an expense account represents the amount of money in the envelope. Budget transactions lead to a new meaning for the balances of expense and income accounts, but it's easy to filter out these transactions to recover the traditional meanings.","title":"Recap"},{"location":"recap/#recap","text":"Envelope Budgeting in Dexter Envelopes are expense accounts, not assets. When a budget transaction fills envelopes it credits expense accounts and debits income accounts . A transaction that debits an expense account automatically uses funds from that envelope; no additional transactions are required. The balance of an expense account represents the amount of money in the envelope. Budget transactions lead to a new meaning for the balances of expense and income accounts, but it's easy to filter out these transactions to recover the traditional meanings.","title":"Recap"},{"location":"regexp/","text":"Regular Expressions TBD How to write regular expressions used by the pair and review commands.","title":"Regular Expressions"},{"location":"regexp/#regular-expressions","text":"TBD How to write regular expressions used by the pair and review commands.","title":"Regular Expressions"},{"location":"tut_accounts/","text":"Command Line Application How to run dex","title":"Command Line Application"},{"location":"tut_accounts/#command-line-application","text":"How to run dex","title":"Command Line Application"},{"location":"tut_fill/","text":"Fill Envelopes This report shows us how much we spent in each expense category: The total in each category is the net amount -- the sum of debits (inflows) minus the sum of credits (outflow). We can see that in detail in the restaurant category: In this section we are going to add the budget transaction that fills the envelopes for each expense category. What we will see is that the budget transaction changes the meaning of expense account balances: when that transaction is added, the balance is interpreted as \"the amount of money left in the envelope\" ( Envelope Budgeting ). Note: In the current version of Dexter budget transactions are added to the database by an import command. In future versions there will be a fill command that automates several of the steps described here. Create the Budget Transaction Use a text editor to create a new transaction in Journal format. The first line should have the transaction date and a brief description (and optionally a comment with extra information). The second line should have a posting with the name of an income account that has money we want to distribute to envelopes adn the amount of money we want to distribute The remaining lines will have the names of expense accounts and the amount of money we want to put in the envelopes for those accounts. Here is the transaction to use for the tutorial project. It allocates most of the monthly paycheck from Yoyodyne (which was for $5,000) to the four expense categories: 2024-04-02 Fill envelopes ; Apr budget: income:yoyodyne $4700.00 expenses:car -$700.00 expenses:entertainment -$200.00 expenses:food -$600.00 expenses:home -$2200.00 That transaction is in a file named fill.apr.journal in the project directory. Important: Note the transaction has a budget: tag. The tag is optional, but if it's there Dexter will be able to remove budget transactions from reports (why that's useful is explained below). Import the Budget Transaction Type this command to preview what will be imported: $ dex --pre import fill.apr.journal None multiple yoyodyne Fill envelopes #budget Two things are worth noting: the credit column says \"multiple\", meaning this transaction will credit more than one account (which is true). the last item on the row is #budget , which is Dexter's syntax for a tag named \"budget\". Type the command again to add the transaction to the database: $ dex import fill.apr.journal Print Food Expenses A quick reminder of how Dexter does envelope budgeting (introduced earlier in Envelope Budgeting : an envelope is an expense account filling the envelope sets a negative balance by crediting the account purchases, which debit the account, add a positive amount, moving the balance closer to $0 if the balance ever gets to $0 it mean the total purchases exceed the original allocation If you look back at the budget fill transaction, you'll see the posting that fills the food envelope put $600 in the account named expenses:food : expenses:food -$600.00 That's the parent account for expenses:food:groceries and expenses:food:restaurant . Any expenses in those two accounts are automatically taken from the food envelope. This command prints a report for all food transactions, including the envelope filling transaction: This is just what we expect! the envelope was initially empty the fill transaction credited the account for $600, setting the balance to -$600 a purchase on Apr 1 took $70 from the envelope and the balance increased to -$530 the next transaction put $35 back in the envelope, so the balance is -$536 The remaining transactions all debited the expense account, taking more money from the envelope. At the end of the month the balance was -$405. This agrees with the summary shown earlier, which said we spent $195 on food. We put in $600, spent $195, and have $405 left. There is one other difference to note. The title bar of this table has a little envelope icon next to the account name. That's there to indicate the report includes an envelope-filling budget transactions. Date for the Budget Transaction You may have noticed the date on the budget fill transaction was April 2. We chose that date because it was the date of the monthly paycheck, so it seemed like a natural time to allocate money to expense categories. There are other strategies that work just as well, and may even make more sense when there are mulitple income sources or income deposits are made later in the month. This topic is covered in the Fill Date section of the Budget Model documentation. Print a Summary of All Expenses This command groups all expenses by the main category (food, car, etc ): The items in the last column show the money left in each envelope at the end of the month. Ignore Budgets Adding the budget transaction changed the meaning of \"account balance\" for expense accounts -- the balance is now the amount left in the envelope (as a negative number). If you want to print a table that shows the original meaning, namely the total amount spent in that category, it's easy to do -- just tell Dexter to ignore that budget transaction. Since the budget transaction is tagged #budget the report generator can simply take those out of the calculation. The --no_budget option tells Dexter to ignore the budget transaction when it prints the summary of all expenses: That's exactly what we saw at the beginning of this section.","title":"Fill Envelopes"},{"location":"tut_fill/#fill-envelopes","text":"This report shows us how much we spent in each expense category: The total in each category is the net amount -- the sum of debits (inflows) minus the sum of credits (outflow). We can see that in detail in the restaurant category: In this section we are going to add the budget transaction that fills the envelopes for each expense category. What we will see is that the budget transaction changes the meaning of expense account balances: when that transaction is added, the balance is interpreted as \"the amount of money left in the envelope\" ( Envelope Budgeting ). Note: In the current version of Dexter budget transactions are added to the database by an import command. In future versions there will be a fill command that automates several of the steps described here.","title":"Fill Envelopes"},{"location":"tut_fill/#create-the-budget-transaction","text":"Use a text editor to create a new transaction in Journal format. The first line should have the transaction date and a brief description (and optionally a comment with extra information). The second line should have a posting with the name of an income account that has money we want to distribute to envelopes adn the amount of money we want to distribute The remaining lines will have the names of expense accounts and the amount of money we want to put in the envelopes for those accounts. Here is the transaction to use for the tutorial project. It allocates most of the monthly paycheck from Yoyodyne (which was for $5,000) to the four expense categories: 2024-04-02 Fill envelopes ; Apr budget: income:yoyodyne $4700.00 expenses:car -$700.00 expenses:entertainment -$200.00 expenses:food -$600.00 expenses:home -$2200.00 That transaction is in a file named fill.apr.journal in the project directory. Important: Note the transaction has a budget: tag. The tag is optional, but if it's there Dexter will be able to remove budget transactions from reports (why that's useful is explained below).","title":"Create the Budget Transaction"},{"location":"tut_fill/#import-the-budget-transaction","text":"Type this command to preview what will be imported: $ dex --pre import fill.apr.journal None multiple yoyodyne Fill envelopes #budget Two things are worth noting: the credit column says \"multiple\", meaning this transaction will credit more than one account (which is true). the last item on the row is #budget , which is Dexter's syntax for a tag named \"budget\". Type the command again to add the transaction to the database: $ dex import fill.apr.journal","title":"Import the Budget Transaction"},{"location":"tut_fill/#print-food-expenses","text":"A quick reminder of how Dexter does envelope budgeting (introduced earlier in Envelope Budgeting : an envelope is an expense account filling the envelope sets a negative balance by crediting the account purchases, which debit the account, add a positive amount, moving the balance closer to $0 if the balance ever gets to $0 it mean the total purchases exceed the original allocation If you look back at the budget fill transaction, you'll see the posting that fills the food envelope put $600 in the account named expenses:food : expenses:food -$600.00 That's the parent account for expenses:food:groceries and expenses:food:restaurant . Any expenses in those two accounts are automatically taken from the food envelope. This command prints a report for all food transactions, including the envelope filling transaction: This is just what we expect! the envelope was initially empty the fill transaction credited the account for $600, setting the balance to -$600 a purchase on Apr 1 took $70 from the envelope and the balance increased to -$530 the next transaction put $35 back in the envelope, so the balance is -$536 The remaining transactions all debited the expense account, taking more money from the envelope. At the end of the month the balance was -$405. This agrees with the summary shown earlier, which said we spent $195 on food. We put in $600, spent $195, and have $405 left. There is one other difference to note. The title bar of this table has a little envelope icon next to the account name. That's there to indicate the report includes an envelope-filling budget transactions.","title":"Print Food Expenses"},{"location":"tut_fill/#date-for-the-budget-transaction","text":"You may have noticed the date on the budget fill transaction was April 2. We chose that date because it was the date of the monthly paycheck, so it seemed like a natural time to allocate money to expense categories. There are other strategies that work just as well, and may even make more sense when there are mulitple income sources or income deposits are made later in the month. This topic is covered in the Fill Date section of the Budget Model documentation.","title":"Date for the Budget Transaction"},{"location":"tut_fill/#print-a-summary-of-all-expenses","text":"This command groups all expenses by the main category (food, car, etc ): The items in the last column show the money left in each envelope at the end of the month.","title":"Print a Summary of All Expenses"},{"location":"tut_fill/#ignore-budgets","text":"Adding the budget transaction changed the meaning of \"account balance\" for expense accounts -- the balance is now the amount left in the envelope (as a negative number). If you want to print a table that shows the original meaning, namely the total amount spent in that category, it's easy to do -- just tell Dexter to ignore that budget transaction. Since the budget transaction is tagged #budget the report generator can simply take those out of the calculation. The --no_budget option tells Dexter to ignore the budget transaction when it prints the summary of all expenses: That's exactly what we saw at the beginning of this section.","title":"Ignore Budgets"},{"location":"tut_import/","text":"Import CSV Files Now that we have the database set up with account names we're ready to import some data. The first step in your monthly workflow will be to connect to your banks and other financial institutions and download all of your transactions. The sample data for this tutorial in the Downloads section of the project folder: Finances ... \u251c\u2500\u2500 Downloads \u2502 \u251c\u2500\u2500 apr \u2502 \u2502 \u251c\u2500\u2500 chase.csv \u2502 \u2502 \u251c\u2500\u2500 checking.csv \u2502 \u2502 \u2514\u2500\u2500 savings.csv \u2502 \u2514\u2500\u2500 may \u2502 \u251c\u2500\u2500 chase.csv \u2502 \u251c\u2500\u2500 checking.csv \u2502 \u2514\u2500\u2500 savings.csv The general form of the import command is $ dex import F1 F2 ... where the names following import are the names of the files to import. In our case, the April data is all in one folder, and we want to import all of the files, so we can just type Downloads/apr/* . File Names An important detail to note here is that the base name of each CSV file matches the abbreviated name of one of the accounts. That's how Dexter knows which account name to use for the new postings it is about to create: records in chase.csv will be assigned to liabilities:visa:chase , and so on. Your typical monthly workflow will probably be something like this: connect to a financial institution's web site select an account, download all transactions find the file in your Downloads folder, rename it, and move it to the downloads section of your project folder It is possible to use a different naming convention, but then files need to be imported one at a time, using the -account option to tell Dexter which account to use, e.g. $ dex import --account chase ~/Downloads/ChaseXXXX_Activity20240101_20240525_20240525.CSV Note : an item high on our TO DO list is to import CSV files downloaded from an aggregator, in which case the account name must be one of the columns in the data file. Preview the April Transactions As a first step we recommend running the command in preview mode. Dexter will parse the files and print the records it will import on the terminal. It's a good way to make sure you're getting the data you expect and to work out any problems with file names or other issues. Here it the command to preview the CSV files for April: $ dex --pre import Downloads/apr/* Verify the Output The output will be shown in sections, one for each input file. A section will start with a log message that looks like this, with the name of the file that will be processed: INFO Parsing Downloads/apr/chase.csv Next are a series of lines, with one line for each CSV record: 2024-04-26 $15.00 visa LONGS MEAT MARKET #unpaired 2024-04-24 $15.00 visa NEWMAN'S FISH COMPANY #unpaired 2024-04-23 $100.00 visa EUGENE WATER AND ELECTRIC #unpaired ... Each of these lines will be saved in the database as a posting. The important information to look for is the date, amount, account, and description. The account shown here will be the full account name. Dexter uses the name of the file (in this case, visa.csv ) to figure out which account to use ( visa is the abbreviation for liabilities:chase:visa ). Note: When you define your own parser you will be making heavy use of preview mode. This is where you will be able to make sure your parser is extracting the right information from the CSV file. Import the April Transactions When everything looks OK, run the same shell command, but without the --preview option: $ dex --db dev import Downloads/apr/* INFO Parsing Downloads/apr/chase.csv INFO Parsing Downloads/apr/checking.csv INFO Parsing Downloads/apr/savings.csv Printing the status of the database should show the new data have been added: $ dex info Databases \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 name \u2503 account \u2503 transaction \u2503 entry \u2503 reg_exp \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 dev \u2502 18 \u2502 2 \u2502 32 \u2502 0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Before there were 4 postings, now there are 32. Save May for Later If you want you can repeat the steps above for the data in the folder for May. But we recommend waiting until you have worked through the complete tutorial. You'll have a smaller and more manageable set of data for each step if you use only the April data the first time through. CSV Transactions Are Saved As Postings The output from the info command brings up an important point about terminology. From the financial institution's perspective, the word \"transaction\" means \"an event that updated the balance of your account\", such as a purchase or a deposit. The web site will show a table of transactions, and most likely the command to save them has a name like \"download transactions\". Each transaction from the financial institution will become a single line in the CSV file. So when we wrote above \"Preview the April Transactions\" we meant \"preview the records in the CSV download for April.\" From Dexter's perspective, however, the word \"transaction\" has the meaning used in double-entry bookkeeping. A transaction is a transfer of money between two (or more) accounts. Each CSV record becomes a posting in the database. So from now on, when we refer to the data we just imported, we will use the DEB terminology and call these items postings. The next step in the expense tracking workflow is to create transactions by pairing the new postings.","title":"Import CSV Files"},{"location":"tut_import/#import-csv-files","text":"Now that we have the database set up with account names we're ready to import some data. The first step in your monthly workflow will be to connect to your banks and other financial institutions and download all of your transactions. The sample data for this tutorial in the Downloads section of the project folder: Finances ... \u251c\u2500\u2500 Downloads \u2502 \u251c\u2500\u2500 apr \u2502 \u2502 \u251c\u2500\u2500 chase.csv \u2502 \u2502 \u251c\u2500\u2500 checking.csv \u2502 \u2502 \u2514\u2500\u2500 savings.csv \u2502 \u2514\u2500\u2500 may \u2502 \u251c\u2500\u2500 chase.csv \u2502 \u251c\u2500\u2500 checking.csv \u2502 \u2514\u2500\u2500 savings.csv The general form of the import command is $ dex import F1 F2 ... where the names following import are the names of the files to import. In our case, the April data is all in one folder, and we want to import all of the files, so we can just type Downloads/apr/* .","title":"Import CSV Files"},{"location":"tut_import/#file-names","text":"An important detail to note here is that the base name of each CSV file matches the abbreviated name of one of the accounts. That's how Dexter knows which account name to use for the new postings it is about to create: records in chase.csv will be assigned to liabilities:visa:chase , and so on. Your typical monthly workflow will probably be something like this: connect to a financial institution's web site select an account, download all transactions find the file in your Downloads folder, rename it, and move it to the downloads section of your project folder It is possible to use a different naming convention, but then files need to be imported one at a time, using the -account option to tell Dexter which account to use, e.g. $ dex import --account chase ~/Downloads/ChaseXXXX_Activity20240101_20240525_20240525.CSV Note : an item high on our TO DO list is to import CSV files downloaded from an aggregator, in which case the account name must be one of the columns in the data file.","title":"File Names"},{"location":"tut_import/#preview-the-april-transactions","text":"As a first step we recommend running the command in preview mode. Dexter will parse the files and print the records it will import on the terminal. It's a good way to make sure you're getting the data you expect and to work out any problems with file names or other issues. Here it the command to preview the CSV files for April: $ dex --pre import Downloads/apr/*","title":"Preview the April Transactions"},{"location":"tut_import/#verify-the-output","text":"The output will be shown in sections, one for each input file. A section will start with a log message that looks like this, with the name of the file that will be processed: INFO Parsing Downloads/apr/chase.csv Next are a series of lines, with one line for each CSV record: 2024-04-26 $15.00 visa LONGS MEAT MARKET #unpaired 2024-04-24 $15.00 visa NEWMAN'S FISH COMPANY #unpaired 2024-04-23 $100.00 visa EUGENE WATER AND ELECTRIC #unpaired ... Each of these lines will be saved in the database as a posting. The important information to look for is the date, amount, account, and description. The account shown here will be the full account name. Dexter uses the name of the file (in this case, visa.csv ) to figure out which account to use ( visa is the abbreviation for liabilities:chase:visa ). Note: When you define your own parser you will be making heavy use of preview mode. This is where you will be able to make sure your parser is extracting the right information from the CSV file.","title":"Verify the Output"},{"location":"tut_import/#import-the-april-transactions","text":"When everything looks OK, run the same shell command, but without the --preview option: $ dex --db dev import Downloads/apr/* INFO Parsing Downloads/apr/chase.csv INFO Parsing Downloads/apr/checking.csv INFO Parsing Downloads/apr/savings.csv Printing the status of the database should show the new data have been added: $ dex info Databases \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 name \u2503 account \u2503 transaction \u2503 entry \u2503 reg_exp \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 dev \u2502 18 \u2502 2 \u2502 32 \u2502 0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Before there were 4 postings, now there are 32.","title":"Import the April Transactions"},{"location":"tut_import/#save-may-for-later","text":"If you want you can repeat the steps above for the data in the folder for May. But we recommend waiting until you have worked through the complete tutorial. You'll have a smaller and more manageable set of data for each step if you use only the April data the first time through.","title":"Save May for Later"},{"location":"tut_import/#csv-transactions-are-saved-as-postings","text":"The output from the info command brings up an important point about terminology. From the financial institution's perspective, the word \"transaction\" means \"an event that updated the balance of your account\", such as a purchase or a deposit. The web site will show a table of transactions, and most likely the command to save them has a name like \"download transactions\". Each transaction from the financial institution will become a single line in the CSV file. So when we wrote above \"Preview the April Transactions\" we meant \"preview the records in the CSV download for April.\" From Dexter's perspective, however, the word \"transaction\" has the meaning used in double-entry bookkeeping. A transaction is a transfer of money between two (or more) accounts. Each CSV record becomes a posting in the database. So from now on, when we refer to the data we just imported, we will use the DEB terminology and call these items postings. The next step in the expense tracking workflow is to create transactions by pairing the new postings.","title":"CSV Transactions Are Saved As Postings"},{"location":"tut_income/","text":"Review Income The envelope filling transaction also changes the interpretation of the balance on income accounts. When there are no budget transactions the balance on an income account is the total amount of income from that source. A budget transaction changes the interpretation to \"the amount of unallocated income.\" This is a report of all income accounts in our database after adding the bucket fill transaction: There are three transactions in this table that are records of when money was deposited in one of our accounts. There is one paycheck, for $5000, deposited into the checking account on Apr 2. There are also two interest deposits, one to each bank account, on Apr 30. These three transactions are the last three rows in the table. As you can see, each of them credits an income source and debits an asset. The credit decreases the balance in the income account. Without the budget transaction the total balance would be -$5002.27: $5000 from Yoyodyne and $2.27 in interest from the bank. The balance would correspond to the sum of all income from all sources. The budget transaction (the second row) has the opposite effect on the balance. Since it debits an income account, it moves the balance in a positive direction. The fact that there is a final balance of -$302.27 tells us we have $302.27 in unallocated funds. That makes sense: we only put $4700 of our $5000 salary in expense accounts, and we haven't found a home yet for the interest income. Put Interest Income in an Envelope If we want to make sure \"every dollar has a job\" we should decide on a place to put the interest income. It's a tiny amount, but it can add up, especially if we're lucky enough to have CD accounts or high-yield savings accounts. The question is, which envelope should we put it in? If you want to put it in the entertainment envelope create a new Journal with this transaction: 2024-04-30 Allocate interest ; Apr budget: income:interest $2.27 expenses:entertainment -$2.27 Save it in a file named interest.apr.journal and import it into the database: $ dex import interest.apr.journal Add a Budget Transaction for the Transfer Our example data set includes a transfer from the checking account to the savings account to set aside $300 for long term goals. That transaction is in the database, which we can see by typing this query, which looks for transactions with the word \"monthly\" in the description: We need to add another new transaction to account for this in our budget. Making a record of the fact that we're allocating $300 to long term savings is easy enough: we just need to add another debit to the ypyodyne account. The budget transaction from the last section had this posting to allocate $4700 to various envelopes: income:yoyodyne $4700.00 We'll do the same thing in the new transaction: income:yoyodyne $300.00 But now the question is, which account do we use for the credit? We clearly don't want to put it in one of our existing expense accounts. One could make a case that \"long term savings\" is an expense and create an account with that name. But there is a better solution, and one that makes sense phisophically. We'll debit the equity account , the account that represents our \"external\" wealth. Create a new file named savings.journal and add this transaction, using the same date as the bank transfer: 2024-04-05 long term savings income:yoyodyne $300.00 equity -$300.00 equity is the account that was used to set the initial balances of our assets: 2023-12-31 initial balance assets:bank:checking $1,000.00 assets:bank:savings $2,500.00 equity -$3,500.00 The value on the last line is the sum of the amounts we had in all our asset accounts. So basically what we're doing with the new transaction is saying \"we are $300 richer than we were.\" Type the shell command that imports savings.journal : $ dex import savings.journal Finally, print the report for income accounts: That's it! The $0.00 balance on the last line means we have accounted for all money deposited in our asset accounts this month, either allocating it to an expense envelope or putting it away in our long term savings.","title":"Review Income"},{"location":"tut_income/#review-income","text":"The envelope filling transaction also changes the interpretation of the balance on income accounts. When there are no budget transactions the balance on an income account is the total amount of income from that source. A budget transaction changes the interpretation to \"the amount of unallocated income.\" This is a report of all income accounts in our database after adding the bucket fill transaction: There are three transactions in this table that are records of when money was deposited in one of our accounts. There is one paycheck, for $5000, deposited into the checking account on Apr 2. There are also two interest deposits, one to each bank account, on Apr 30. These three transactions are the last three rows in the table. As you can see, each of them credits an income source and debits an asset. The credit decreases the balance in the income account. Without the budget transaction the total balance would be -$5002.27: $5000 from Yoyodyne and $2.27 in interest from the bank. The balance would correspond to the sum of all income from all sources. The budget transaction (the second row) has the opposite effect on the balance. Since it debits an income account, it moves the balance in a positive direction. The fact that there is a final balance of -$302.27 tells us we have $302.27 in unallocated funds. That makes sense: we only put $4700 of our $5000 salary in expense accounts, and we haven't found a home yet for the interest income.","title":"Review Income"},{"location":"tut_income/#put-interest-income-in-an-envelope","text":"If we want to make sure \"every dollar has a job\" we should decide on a place to put the interest income. It's a tiny amount, but it can add up, especially if we're lucky enough to have CD accounts or high-yield savings accounts. The question is, which envelope should we put it in? If you want to put it in the entertainment envelope create a new Journal with this transaction: 2024-04-30 Allocate interest ; Apr budget: income:interest $2.27 expenses:entertainment -$2.27 Save it in a file named interest.apr.journal and import it into the database: $ dex import interest.apr.journal","title":"Put Interest Income in an Envelope"},{"location":"tut_income/#add-a-budget-transaction-for-the-transfer","text":"Our example data set includes a transfer from the checking account to the savings account to set aside $300 for long term goals. That transaction is in the database, which we can see by typing this query, which looks for transactions with the word \"monthly\" in the description: We need to add another new transaction to account for this in our budget. Making a record of the fact that we're allocating $300 to long term savings is easy enough: we just need to add another debit to the ypyodyne account. The budget transaction from the last section had this posting to allocate $4700 to various envelopes: income:yoyodyne $4700.00 We'll do the same thing in the new transaction: income:yoyodyne $300.00 But now the question is, which account do we use for the credit? We clearly don't want to put it in one of our existing expense accounts. One could make a case that \"long term savings\" is an expense and create an account with that name. But there is a better solution, and one that makes sense phisophically. We'll debit the equity account , the account that represents our \"external\" wealth. Create a new file named savings.journal and add this transaction, using the same date as the bank transfer: 2024-04-05 long term savings income:yoyodyne $300.00 equity -$300.00 equity is the account that was used to set the initial balances of our assets: 2023-12-31 initial balance assets:bank:checking $1,000.00 assets:bank:savings $2,500.00 equity -$3,500.00 The value on the last line is the sum of the amounts we had in all our asset accounts. So basically what we're doing with the new transaction is saying \"we are $300 richer than we were.\" Type the shell command that imports savings.journal : $ dex import savings.journal Finally, print the report for income accounts: That's it! The $0.00 balance on the last line means we have accounted for all money deposited in our asset accounts this month, either allocating it to an expense envelope or putting it away in our long term savings.","title":"Add a Budget Transaction for the Transfer"},{"location":"tut_init/","text":"Initialize the Database To create the database for the tutorial project simply type $ dex init --file accounts.csv Dexter will find the name for the new database in the configuration file, create the database, and add the accounts. If you get a \"database exists\" error see below. Note: You can use accounts.journal instead of accounts.csv . They have the same definitions, just in different formats. Dexter will figure out which format to use based on the file name extension. You can use the info command to verify the database was created: $ dex info Databases \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 name \u2503 account \u2503 transaction \u2503 entry \u2503 reg_exp \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 dev \u2502 18 \u2502 2 \u2502 4 \u2502 0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 The table will have one row for each database on the server. Since this is the first Dexter database you have created you will see only one row. That output shows there are two transactions in the database already. Those are the transactions that set the starting balance of the checking and savings accounts. You can also use the select command (introduced later, in Select Transactions ) to print descriptions of the transactions: $ dex --db dev select Transactions \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 date \u2503 credit \u2503 debit \u2503 amount \u2503 description \u2503 comment \u2503 tags \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 2023-12-31 \u2502 equity \u2502 checking \u2502 $1,000.00 \u2502 initial balance \u2502 \u2502 \u2502 \u2502 2023-12-31 \u2502 equity \u2502 savings \u2502 $2,500.00 \u2502 initial balance \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Note: The initial balances are defined with the account names in accounts.csv . For more information about what else can be put in this file see Defining Accounts . Database Exists Error If there is already a database on the server Dexter will print an error message like this: ERROR database dev exists; use --force to replace it This policy is in place to prevent users from accidentally overwriting previous data. If you really did mean to replace the old data, run the command again, and add a --force option to the end of the command line: $ dex init --file accounts.csv --force On the other hand, if you want to save the existing database, you can initialize a new one by specifying a different name. You can edit the config file, so that this command and future commands use a different name, or you can use --dbname to specify the name for just this command: $ dex --dbname my_dev init --file accounts.csv --force","title":"Initialize the Database"},{"location":"tut_init/#initialize-the-database","text":"To create the database for the tutorial project simply type $ dex init --file accounts.csv Dexter will find the name for the new database in the configuration file, create the database, and add the accounts. If you get a \"database exists\" error see below. Note: You can use accounts.journal instead of accounts.csv . They have the same definitions, just in different formats. Dexter will figure out which format to use based on the file name extension. You can use the info command to verify the database was created: $ dex info Databases \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 name \u2503 account \u2503 transaction \u2503 entry \u2503 reg_exp \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 dev \u2502 18 \u2502 2 \u2502 4 \u2502 0 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 The table will have one row for each database on the server. Since this is the first Dexter database you have created you will see only one row. That output shows there are two transactions in the database already. Those are the transactions that set the starting balance of the checking and savings accounts. You can also use the select command (introduced later, in Select Transactions ) to print descriptions of the transactions: $ dex --db dev select Transactions \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 date \u2503 credit \u2503 debit \u2503 amount \u2503 description \u2503 comment \u2503 tags \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 2023-12-31 \u2502 equity \u2502 checking \u2502 $1,000.00 \u2502 initial balance \u2502 \u2502 \u2502 \u2502 2023-12-31 \u2502 equity \u2502 savings \u2502 $2,500.00 \u2502 initial balance \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Note: The initial balances are defined with the account names in accounts.csv . For more information about what else can be put in this file see Defining Accounts .","title":"Initialize the Database"},{"location":"tut_init/#database-exists-error","text":"If there is already a database on the server Dexter will print an error message like this: ERROR database dev exists; use --force to replace it This policy is in place to prevent users from accidentally overwriting previous data. If you really did mean to replace the old data, run the command again, and add a --force option to the end of the command line: $ dex init --file accounts.csv --force On the other hand, if you want to save the existing database, you can initialize a new one by specifying a different name. You can edit the config file, so that this command and future commands use a different name, or you can use --dbname to specify the name for just this command: $ dex --dbname my_dev init --file accounts.csv --force","title":"Database Exists Error"},{"location":"tut_pair/","text":"Pair Transactions Now that the database has regular expressions we can run the pair command. As usual, we recommend doing a preview first: $ dex --pre pair Output Tables The preview output will have three sections. The first is a list of new transactions that will be made as a result of a successful match with a regular expression: Matched (14) 2024-04-26 visa groceries $15.00 Long's Meat Market 2024-04-24 visa groceries $15.00 Newman's 2024-04-23 visa utility $100.00 EWEB ... This is exactly what we want from the regular expressions. Each of these lines is a transaction that created by pairing a posting based on a CSV record from chase.csv with a new posting for an expense category. There are two column names on each line. The first is the credit (source) account, and the second is debit (destination) account. So first line shows a charge on the Visa card to pay for groceries at a local butcher shop. It's worth mentioning that while most records in the CSV file are purchases, and thus credits to the account, some will be debits, and the regular expression process correctly handles these situations. Here is an example from later in that output section: 2024-04-30 interest checking $0.68 Interest That posting came from checking.csv , and corresponds to a deposit into that account. The record in the CSV file was a debit, and the algorithm paired it with a credit to income:interest . The second section shows transfers, i.e. new transcations that were formed by matching the two ends of a bank transfer or card payment. Our sample data has one of each: Transfers (2) 2024-04-15 checking visa $489.73 Chase Payment 2024-04-05 checking savings $300.00 Transfer Monthly Finally, the pair command prints a list of postings that did not match regular expressions: Unmatched (10) visa JERRYS HOME EUGENE visa JERRYS HOME EUGENE visa AMZN Mktp US*MU3CW2U53 ... Optional: Update the Regular Expressions There are different kinds of postings in the unmatched section. The first line is for a purchase at Amazon.com. Amazon doesn't give us any information about what that purchase was, so we have no way of writing a regular expression rule to fill in the expense category. We'll have to deal with this manually later in the workflow. The second line is for a company named Jerry's. In this case it might be possible to write a new rule. If you do a lot of business at a company it would be worthwhile taking some time to add a new rule. In this case we would make a rule saying \"every purchase at Jerry's should be to expenses:home:household .\" You can find more information about how to create and test new rules in Regular Expressions . A suggested workflow, especially for the first few months you use Dexter, is to run pair in preview mode, scan the output to find new rules to add, update regexp.csv and import it again, and then run pair again. Make New Transactions When you're ready to actually create the new transactions, run the command again, without the --preview option: $ dex pair Run the info command again to see the updated state of the database: $ dex info Databases \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 name \u2503 account \u2503 transaction \u2503 entry \u2503 reg_exp \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 dev \u2502 18 \u2502 18 \u2502 46 \u2502 29 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Our database is growing -- we have several new postings and transactions!","title":"Pair Entries"},{"location":"tut_pair/#pair-transactions","text":"Now that the database has regular expressions we can run the pair command. As usual, we recommend doing a preview first: $ dex --pre pair","title":"Pair Transactions"},{"location":"tut_pair/#output-tables","text":"The preview output will have three sections. The first is a list of new transactions that will be made as a result of a successful match with a regular expression: Matched (14) 2024-04-26 visa groceries $15.00 Long's Meat Market 2024-04-24 visa groceries $15.00 Newman's 2024-04-23 visa utility $100.00 EWEB ... This is exactly what we want from the regular expressions. Each of these lines is a transaction that created by pairing a posting based on a CSV record from chase.csv with a new posting for an expense category. There are two column names on each line. The first is the credit (source) account, and the second is debit (destination) account. So first line shows a charge on the Visa card to pay for groceries at a local butcher shop. It's worth mentioning that while most records in the CSV file are purchases, and thus credits to the account, some will be debits, and the regular expression process correctly handles these situations. Here is an example from later in that output section: 2024-04-30 interest checking $0.68 Interest That posting came from checking.csv , and corresponds to a deposit into that account. The record in the CSV file was a debit, and the algorithm paired it with a credit to income:interest . The second section shows transfers, i.e. new transcations that were formed by matching the two ends of a bank transfer or card payment. Our sample data has one of each: Transfers (2) 2024-04-15 checking visa $489.73 Chase Payment 2024-04-05 checking savings $300.00 Transfer Monthly Finally, the pair command prints a list of postings that did not match regular expressions: Unmatched (10) visa JERRYS HOME EUGENE visa JERRYS HOME EUGENE visa AMZN Mktp US*MU3CW2U53 ...","title":"Output Tables"},{"location":"tut_pair/#optional-update-the-regular-expressions","text":"There are different kinds of postings in the unmatched section. The first line is for a purchase at Amazon.com. Amazon doesn't give us any information about what that purchase was, so we have no way of writing a regular expression rule to fill in the expense category. We'll have to deal with this manually later in the workflow. The second line is for a company named Jerry's. In this case it might be possible to write a new rule. If you do a lot of business at a company it would be worthwhile taking some time to add a new rule. In this case we would make a rule saying \"every purchase at Jerry's should be to expenses:home:household .\" You can find more information about how to create and test new rules in Regular Expressions . A suggested workflow, especially for the first few months you use Dexter, is to run pair in preview mode, scan the output to find new rules to add, update regexp.csv and import it again, and then run pair again.","title":"Optional: Update the Regular Expressions"},{"location":"tut_pair/#make-new-transactions","text":"When you're ready to actually create the new transactions, run the command again, without the --preview option: $ dex pair Run the info command again to see the updated state of the database: $ dex info Databases \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 name \u2503 account \u2503 transaction \u2503 entry \u2503 reg_exp \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 dev \u2502 18 \u2502 18 \u2502 46 \u2502 29 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Our database is growing -- we have several new postings and transactions!","title":"Make New Transactions"},{"location":"tut_recap/","text":"Recap That's the end of the tutorial. In the previous sections you created a new database and worked through the main steps in Dexter's monthly financial tracking workflow: Import records downloaded from banks and card companies. Each record is saved as a new credit or debit posting in the database. Use Dexter's \"pair\" operation to automatically create as many transactions as possible. New transactions are formed by matching two postings, one a credit and the other a debit. In some cases both postings are already in the database, in others Dexter uses regular expressions to infer a new posting. Use a command line based read-eval-print loop to pair the remaining postings. This step is designed to do as much as possible with a few keystrokes. Use additional commands to select and view transactions based on attributes (date, amount, description, etc ) or print reports with account balances. There are several more things Dexter can help with. They are described in User Documentation section of this website: Back up or restore a database, using one of two formats. A \"dox file\" is basically a JSON file with one line per record. The other uses MongoDB commands to make a binary file. Export records to a Journal file so they can be incorporated into Ledger or hledger . Edit or delete records, either individually or in bulk. Additional report types. Commands that reconcile credit card and bank statements, making sure the records in a database match records reported by a financial institution. Note: Some of these operations are working in my old SQLite-based scripts but haven't yet been converted to work with the new database schema.","title":"Recap"},{"location":"tut_recap/#recap","text":"That's the end of the tutorial. In the previous sections you created a new database and worked through the main steps in Dexter's monthly financial tracking workflow: Import records downloaded from banks and card companies. Each record is saved as a new credit or debit posting in the database. Use Dexter's \"pair\" operation to automatically create as many transactions as possible. New transactions are formed by matching two postings, one a credit and the other a debit. In some cases both postings are already in the database, in others Dexter uses regular expressions to infer a new posting. Use a command line based read-eval-print loop to pair the remaining postings. This step is designed to do as much as possible with a few keystrokes. Use additional commands to select and view transactions based on attributes (date, amount, description, etc ) or print reports with account balances. There are several more things Dexter can help with. They are described in User Documentation section of this website: Back up or restore a database, using one of two formats. A \"dox file\" is basically a JSON file with one line per record. The other uses MongoDB commands to make a binary file. Export records to a Journal file so they can be incorporated into Ledger or hledger . Edit or delete records, either individually or in bulk. Additional report types. Commands that reconcile credit card and bank statements, making sure the records in a database match records reported by a financial institution. Note: Some of these operations are working in my old SQLite-based scripts but haven't yet been converted to work with the new database schema.","title":"Recap"},{"location":"tut_regexp/","text":"Import Regular Expressions The next step in the workflow is to \"pair\" the postings we just imported. Dexter uses pattern matching rules as a key part of this process. So before we run the pair command we have to load the patterns into the database. The pattern matching rules for the tutorial are in a file named regexp.csv . You do not need to make any changes to this file, but you can open it with a text editor while you are reading the examples shown below. A Pairing Example As an example of what we want the pair command to do, consider one of the postings created by importing the checking account data: 2024-04-24 -$15.00 visa NEWMAN'S FISH COMPANY #unpaired The minus sign in the amount means it is a credit (withdrawal) to the checking account. Note: the terminal output shows credits/negative numbers in red, without the minus sign. If we regularly shop at this store we will see this kind of posting again in the future. Our monthly financial workflow would be more efficient if Dexter could automatically create a new transaction for us: whenever it sees a credit with a description that matches \"NEWMAN\" it should create a debit to expenses:food:groceries . It could then create a new transaction using the two postings. Pairing Rules The key word in that previous paragraph is \"match\". Dexter uses Python regular expressions to make pairs of postings. For each record read from a CSV file, it looks through a set of pairing rules to find a rule that can be applied to the CSV record. The parts of a rule are: a pattern to match against the posting description the action to take when a description matches the pattern the account name to use for the new pairing a pattern for the transaction description As an example, here is the rule for Newman's: trans,NEWMAN,Newman's Fish,groceries The parts are: trans is the action to take -- it means \"make a new transaction\" \"NEWMAN\" is the pattern \"Newman's Fish\" is the description that will go in the new transaction the last column is the account name to use in the new posting The pattern and new description in this example are pretty boring -- all the rule is doing is turning the all-uppercase input into a more readable mixed case. In other cases, however, the pattern matching rules can be very helpful. For example, a CSV record in the checking account can have a description like \"Payment to Chase Credit Card\" or \"\"Payment to Citi Credit Card\". We can make a rule that matches any card name and then include that name in the transaction description: xfer,Payment to (\\w+),{0} Payment, The \\w+ in the pattern means \"any string of letters\" and the {0} in the new description means \"whatever letters were found in the input\". The full set of instructions for writing pairing rules can be found in Regular Expressions . Transfers The xfer in the rule shown above for the Chase payment is a second type of action the pair script can take. Here the goal isn't to create a new posting but to try to find two complementary postings that already exist. In this case, if there is a card payment made from the checking account, there should be a matching deposit in the credit card account. Transfer rules are also used for transactions that move money between bank accounts. The sample data has a transfer from checking to savings each month. In each case -- card payments and bank transfers -- the pairing rules should have patterns that tell Dexter how to identify the two halves of a transfer so it can pair them to make a new transaction. fill and sub Rules The CSV file can have two other kinds of rules, called \"fill\" and \"sub\" (short for \"substitution\") rules. These are used by the review command, so we won't discuss them until that section of the tutorial. The regexp.csv File Pairing rules need to be saved in a CSV file and then loaded into the database. Adding rules to the database uses the same import command that parses downloads. Simply add the --regexp option to tell Dexter that the file being imported has pairing rules instead of downloaded transactions. The rules for the sample data are in a file named regexp.csv . Type this command to add them to the dev database: $ dex import --regexp regexp.csv Run the info command again, and now you will see the pairing rules have been added (the count in the reg_exp column changes from 0 to 29): $ dex info Databases \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 name \u2503 account \u2503 transaction \u2503 entry \u2503 reg_exp \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 dev \u2502 18 \u2502 2 \u2502 32 \u2502 29 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Import Regular Expressions"},{"location":"tut_regexp/#import-regular-expressions","text":"The next step in the workflow is to \"pair\" the postings we just imported. Dexter uses pattern matching rules as a key part of this process. So before we run the pair command we have to load the patterns into the database. The pattern matching rules for the tutorial are in a file named regexp.csv . You do not need to make any changes to this file, but you can open it with a text editor while you are reading the examples shown below.","title":"Import Regular Expressions"},{"location":"tut_regexp/#a-pairing-example","text":"As an example of what we want the pair command to do, consider one of the postings created by importing the checking account data: 2024-04-24 -$15.00 visa NEWMAN'S FISH COMPANY #unpaired The minus sign in the amount means it is a credit (withdrawal) to the checking account. Note: the terminal output shows credits/negative numbers in red, without the minus sign. If we regularly shop at this store we will see this kind of posting again in the future. Our monthly financial workflow would be more efficient if Dexter could automatically create a new transaction for us: whenever it sees a credit with a description that matches \"NEWMAN\" it should create a debit to expenses:food:groceries . It could then create a new transaction using the two postings.","title":"A Pairing Example"},{"location":"tut_regexp/#pairing-rules","text":"The key word in that previous paragraph is \"match\". Dexter uses Python regular expressions to make pairs of postings. For each record read from a CSV file, it looks through a set of pairing rules to find a rule that can be applied to the CSV record. The parts of a rule are: a pattern to match against the posting description the action to take when a description matches the pattern the account name to use for the new pairing a pattern for the transaction description As an example, here is the rule for Newman's: trans,NEWMAN,Newman's Fish,groceries The parts are: trans is the action to take -- it means \"make a new transaction\" \"NEWMAN\" is the pattern \"Newman's Fish\" is the description that will go in the new transaction the last column is the account name to use in the new posting The pattern and new description in this example are pretty boring -- all the rule is doing is turning the all-uppercase input into a more readable mixed case. In other cases, however, the pattern matching rules can be very helpful. For example, a CSV record in the checking account can have a description like \"Payment to Chase Credit Card\" or \"\"Payment to Citi Credit Card\". We can make a rule that matches any card name and then include that name in the transaction description: xfer,Payment to (\\w+),{0} Payment, The \\w+ in the pattern means \"any string of letters\" and the {0} in the new description means \"whatever letters were found in the input\". The full set of instructions for writing pairing rules can be found in Regular Expressions .","title":"Pairing Rules"},{"location":"tut_regexp/#transfers","text":"The xfer in the rule shown above for the Chase payment is a second type of action the pair script can take. Here the goal isn't to create a new posting but to try to find two complementary postings that already exist. In this case, if there is a card payment made from the checking account, there should be a matching deposit in the credit card account. Transfer rules are also used for transactions that move money between bank accounts. The sample data has a transfer from checking to savings each month. In each case -- card payments and bank transfers -- the pairing rules should have patterns that tell Dexter how to identify the two halves of a transfer so it can pair them to make a new transaction.","title":"Transfers"},{"location":"tut_regexp/#fill-and-sub-rules","text":"The CSV file can have two other kinds of rules, called \"fill\" and \"sub\" (short for \"substitution\") rules. These are used by the review command, so we won't discuss them until that section of the tutorial.","title":"fill and sub Rules"},{"location":"tut_regexp/#the-regexpcsv-file","text":"Pairing rules need to be saved in a CSV file and then loaded into the database. Adding rules to the database uses the same import command that parses downloads. Simply add the --regexp option to tell Dexter that the file being imported has pairing rules instead of downloaded transactions. The rules for the sample data are in a file named regexp.csv . Type this command to add them to the dev database: $ dex import --regexp regexp.csv Run the info command again, and now you will see the pairing rules have been added (the count in the reg_exp column changes from 0 to 29): $ dex info Databases \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 name \u2503 account \u2503 transaction \u2503 entry \u2503 reg_exp \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 dev \u2502 18 \u2502 2 \u2502 32 \u2502 29 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"The regexp.csv File"},{"location":"tut_report/","text":"Reports The report command is similar to select , in that it will print tables showing transaction data. The differences are: report automatically organizes data by account name the tables include account balances data can be grouped to show total amounts in each account Single Account To see a list of all transactions in an account type the account name after report . The name can be a full name, e.g. assets:bank:checking or an abbreviated name, e.g. checking : There will be one row for each transaction where the account is used either as the credit (source) account or debit (destination) account. Since we asked Dexter to print a report for the checking account, that account name should show up in either the credit column or debit column of the table. Notice how when checking is in the credit column the transaction was taking money from checking and moving it to the other account and the amount is negative. The opposite is true when checking is the debit account: the other account is the source in the credit column and the amount is positive. Note: for brevity the initial part of an account name ( income: , expenses: , _etc ) is not printed. Multiple Accounts If more than one account is entered Dexter will print a table for each account: Since one of our transactions was a transfer from checking to savings that transaction appears in both tables. In the checking account table the account was the credit account and the posting decreased the account balance, but in the other table the account was the debit account the the posting increased the balance. Include Subaccounts If the account name ends with a colon Dexter includes transactions for that account and all of its subaccounts. For example, we have an account expenses:food with subaccounts expenses:food:groceries and expenses:food:restaurant . This command prints a table will transactions from all three accounts: The balance on the last line shows that we spent a total of $195 on food in April. Separate Tables for Subaccounts The notation X: means \"make a single table using account X and all its subaccounts\". A slight variation is to put a number after the colon. X:n means \"make separate tables for X and all its subaccounts n levels down\". So expenses:food:1 tells Dexter to print a table for expenses:food and its two top level subaccounts: The first table is for expenses:food . We didn't have any transactions for this category -- all our purchases went to either groceries or restaurant -- but this account is available for miscellaneous purchases (snacks?) that don't fit in either of the subaccounts. Subsubaccounts We don't have any subaccounts below groceries or restaurant , but if we did those would be put in the corresponding table. For example, we might add new accounts named expenses:food:restaurant:fastfood , expenses:food:restaurant:fancy , etc . Any expenses in those categories would be collected into the restaurant table. If we have those extra subaccounts we can print separate tables for them, too, by specifying expenses:food:2 on the command line, meaing \"separate tables for food and all subaccounts down two levels.\" Notation A mnemonic for rememberis the difference between X: (without a level number) and X:n is to think of the colon at the end as an asterisk in a shell command: \"expenses:food:\" is like \"expenses:food*\", which is a pattern that would match any file with a name that starts \"expenses:food\". We considered using an asterisk instead of a colon at the end of an account name but that makes it harder to type the shell command since shells have their own meaning for the asterisk. We would have to put single quotes around the account name and type $ dex report 'expenses:food*' _A future version might accept either notation. Groups A --grouped option along with a name pattern that would make separate tables tells Dexter to compute the balance of each table and then collect the results into a single table to print:","title":"Print Reports"},{"location":"tut_report/#reports","text":"The report command is similar to select , in that it will print tables showing transaction data. The differences are: report automatically organizes data by account name the tables include account balances data can be grouped to show total amounts in each account","title":"Reports"},{"location":"tut_report/#single-account","text":"To see a list of all transactions in an account type the account name after report . The name can be a full name, e.g. assets:bank:checking or an abbreviated name, e.g. checking : There will be one row for each transaction where the account is used either as the credit (source) account or debit (destination) account. Since we asked Dexter to print a report for the checking account, that account name should show up in either the credit column or debit column of the table. Notice how when checking is in the credit column the transaction was taking money from checking and moving it to the other account and the amount is negative. The opposite is true when checking is the debit account: the other account is the source in the credit column and the amount is positive. Note: for brevity the initial part of an account name ( income: , expenses: , _etc ) is not printed.","title":"Single Account"},{"location":"tut_report/#multiple-accounts","text":"If more than one account is entered Dexter will print a table for each account: Since one of our transactions was a transfer from checking to savings that transaction appears in both tables. In the checking account table the account was the credit account and the posting decreased the account balance, but in the other table the account was the debit account the the posting increased the balance.","title":"Multiple Accounts"},{"location":"tut_report/#include-subaccounts","text":"If the account name ends with a colon Dexter includes transactions for that account and all of its subaccounts. For example, we have an account expenses:food with subaccounts expenses:food:groceries and expenses:food:restaurant . This command prints a table will transactions from all three accounts: The balance on the last line shows that we spent a total of $195 on food in April.","title":"Include Subaccounts"},{"location":"tut_report/#separate-tables-for-subaccounts","text":"The notation X: means \"make a single table using account X and all its subaccounts\". A slight variation is to put a number after the colon. X:n means \"make separate tables for X and all its subaccounts n levels down\". So expenses:food:1 tells Dexter to print a table for expenses:food and its two top level subaccounts: The first table is for expenses:food . We didn't have any transactions for this category -- all our purchases went to either groceries or restaurant -- but this account is available for miscellaneous purchases (snacks?) that don't fit in either of the subaccounts.","title":"Separate Tables for Subaccounts"},{"location":"tut_report/#subsubaccounts","text":"We don't have any subaccounts below groceries or restaurant , but if we did those would be put in the corresponding table. For example, we might add new accounts named expenses:food:restaurant:fastfood , expenses:food:restaurant:fancy , etc . Any expenses in those categories would be collected into the restaurant table. If we have those extra subaccounts we can print separate tables for them, too, by specifying expenses:food:2 on the command line, meaing \"separate tables for food and all subaccounts down two levels.\"","title":"Subsubaccounts"},{"location":"tut_report/#notation","text":"A mnemonic for rememberis the difference between X: (without a level number) and X:n is to think of the colon at the end as an asterisk in a shell command: \"expenses:food:\" is like \"expenses:food*\", which is a pattern that would match any file with a name that starts \"expenses:food\". We considered using an asterisk instead of a colon at the end of an account name but that makes it harder to type the shell command since shells have their own meaning for the asterisk. We would have to put single quotes around the account name and type $ dex report 'expenses:food*' _A future version might accept either notation.","title":"Notation"},{"location":"tut_report/#groups","text":"A --grouped option along with a name pattern that would make separate tables tells Dexter to compute the balance of each table and then collect the results into a single table to print:","title":"Groups"},{"location":"tut_review/","text":"Review Unpaired Entries After importing a batch of CSV files, the pair command will automatically generate matches for most of the new postings, but there will probably be several more that need to be processed by hand. The select command (described in more detail in Select Transactions ) has a set of options that will print a table showing all the unpaired entries: $ dex select --entry --tag '#unpaired' \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 date \u2503 account \u2503 amount \u2503 column \u2503 description \u2503 tags \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 2024-04-01 \u2502 checking \u2502 $70.00 \u2502 credit \u2502 Check # 153: Completed/Check \u2026 \u2502 #unpaired \u2502 \u2502 2024-04-02 \u2502 visa \u2502 $5.00 \u2502 credit \u2502 WASH-IT EXPRESS \u2502 #unpaired \u2502 \u2502 2024-04-03 \u2502 checking \u2502 $35.00 \u2502 debit \u2502 Transfer from Venmo/VENMO - \u2026 \u2502 #unpaired \u2502 \u2502 2024-04-03 \u2502 checking \u2502 $50.00 \u2502 credit \u2502 KAYENTA CHEV-XX6444 JUNCTION \u2026 \u2502 #unpaired \u2502 ... Overview To start the review process simply type the command name: $ dex review Dexter will show us the unpaired postings one at a time. It will create the outline of a new transaction, leaving blanks for places we can fill in. The display will be a table that has the general shape of a transaction in Journal format: the top line will have the date and transaction description the next line will be the posting corresponding to the CSV record that was imported the third line will be the outline of a new posting where we need to supply the account name This is what the display looks like for the first entry shown above: The blanks we can fill in are shown with a light background and a reminder (in italics) of what goes in that blank. After we fill in the description and account fields for this transaction the display will look like this: The filled-in fields are displayed in a different color to indicate they have been edited. Every new transaction must have the description and account fields filled in; the comment and tags are optional. At this point we can save current transaction. They display will be updated to show the next unpaired entry from the list. Philosophy The obvious question at this point is, why go to all the effort to make a new command just to review postings? Wouldn't it be easier to export the data to a spreadsheet of other application and let users work with a GUI they are already familiar with? The answer is that Dexter's command line interface is much more efficient. With a GUI display in a spreadsheet or text editor, users choose items that need to be updated. They click on an item and then edit one or more fields. Dexter knows which items need attention, and it displays them to us one at a time. The efficiency comes from being able to use features like command completion and command line editing to update the current item. In many cases it can take only a few keystrokes (and no mouse clicks) to fill in the missing data and move on to the next item. Example Let's work through the steps used to edit the posting shown above, which will illustrate several of Dexter's time-saving operations. At each step we'll start an edting operation by typing a single keystroke. The notation \u2303X is short for \"control-X\", i.e. hold down the control key when typing X. Auto-Fill Command The description field in a new transaction is blank because none of the regular expressions matched the description in the CSV record. The CSV description is useful, however, so Dexter saves it as part of the posting. You can see the CSV description (\"Check # 152: ...\") on the right part of the second line. The auto-fill command (\u2303F) copies information from the posting description and inserts it in the transaction description area. the first time we hit \u2303F Dexter copies the posting description the next time we type that Key Dexter will apply the \"fill\" and \"sub\" regular expressions mentioned briefly in Regular Expressions and insert the result if we hit \u2303F a third time the area goes back to the original blank state (with just the placeholder) This is what the terminal window shows after hitting \u2303F the first time: And this is the window after the second \u2303F: The regular expressions (described below) have stripped away all of the extra text following the colon. You can hit \u2303F a few more times to see how Dexter cycles through the three alternatives. Make sure it is displaying the third alternative (created by the regular expressions) before moving on to the next step. Edit the Description Notice how the text displayed in the transaction description area is still in italics. That's because the fill command simply makes suggestions for what the description should look like. We often want to edit the field to refine that suggestion. To edit the description field hit \u2303P. The \"P\" is short for \"payee\". We can't use \u2303D because that's a Unix convention for signalling the end of input and the command to exit the program. This is what the screen will look like: Whenever you are editing a field, Dexter will prompt you to enter the contents. It will print a line with the field name followed by a greater-than sign and then the current contents of the field. In this example, it printed the suggested contents of the description field. The cursor is at the end of the line, which means we just need to type in the name of the person or business we wrote the check to. Type \"Glenwood\" and hit the return key. Now the new transaction will look like this: The most important thing to notice here is that the text format has changed: it's now blue on a white background. That means the field has been edited and has a value that will be saved in the database. Command Line Editing Dexter uses a popular library named GNU Readline to control the editing of fields. You are probably already familiar with the keystrokes you can use, since most shells use this library (or an equivalent). use \u2303A or \u2303E to move the cursor to the front or end of the line use left-arrow and right-arrow keys or type \u2303B or \u2303F to move backward or forward one character type ESC followed by B or F to move backward or forward one word at a time type DEL to delete the character to the left, ESC DEL to delete the word to the left \u2303U deletes the entire line The complete set of editing keys can be found in the Reference section, in dex Review . Edit the Account Name To edit the account name in the new posting type \u2303T. The \"T\" is short for \"to\", since this posting is usually the destination (credit) account in the transaction. As before, Dexter prints a new line for you to enter the account name: This is where another traditional command line editing feature will be very useful. You can type part of a command name and then hit the tab key. If the part you typed is sufficient to distinguish the account from all the other accounts Dexter will fill in the rest of the name for you. This transaction is something that should go in the restaurant expenses category, expense:food:restaurant . That account has an abbreviation of \"restaurant\". Type \"re\" and hit the tab key. Dexter will fill in the rest, and the line will show \"restaurant\". Now hit the return key, and you can see Dexter has expanded the abbreviation into the full account name: Notes on Line Completion If you're entering a string and hit the tab key and nothing happens it probably you didn't type enough to disambiguate the account you want from other accounts. Hit the tab key a second time and Dexter will show you all the accounts that start with the text you typed. For example, suppose you wanted to classify the Glenwood transaction as a household expense and want to assign expenses:home:household as the account. If you just type \"ho\" and hit tab nothing happens. Hit tab again and this is that you'll see: Dexter is saying there are two accounts that start with \"ho\": \"home\" and \"household\". At this point just continue typing. Since we want \"household\" in this case just typing \"u\" and tab is enough. Note: Another reason you won't see anything happen when you hit the tab key is that you misspelled an account name. For example, if you type \"hoo\" you can hit the tab key as often as you want. Dexter is telling you no account starts \"hoo\". If you really meant \"hou\" hit the delete key to erase the \"o\", then type \"u\" and tab. Accept Changes The last step is to tell Dexter we're done with this transaction. Type \u2303A (the \"A\" is for \"accept\"). Dexter will add the new posting and the new transaction to the database and move on to the next unpaired posting. Exit To exit the program type \u2303C or \u2303D. You can verify the new transaction and posting were added to the database: if you run dex info you will see the count in those two columns has increased by one you can run the select command that prints the list of unpaired entries (shown at the top of this page) to see that the check posting is no longer on this list. Restart When you restart Dexter to work on the remaining transactions add an option to the review command: dex review --fill_mode 2 That tells Dexter to automatically fill each transaction description. Mode number 2 is \"apply regular expressions to the posting description\". Now we don't have to type \u2303F -- it will be done already. If you want to use another mode for any transaction you can still type \u2303F to cycle through the modes. Display Help If you need a reminder of which control keys trigger the editing operations just type a question mark when Dexter is showing a transaction. This message will be displayed: Fill in the Second Transaction The next transaction was a purchase at a car wash. We want to assign expenses:car as the account. If you type \u2303T to edit the account, type \"car\", and hit return you'll see an error message: The problem here is that we defined three accounts with the string \"car\" in the name. To fix this problem you need to type the full account name. But completion can still help save keystrokes. Type \"ex\" and tab, and the line will expand to \"expenses\". Now type a colon and \"ca\" and tab again, and the line will show \"expenses:car\". Hit return to enter that name in the transaction box. The display will look like this: Next, look at the filled in transaction description. The regular expression has transformed it into \"title-case\": the first letter in each word is capitalized, the rest are lower case. There's no need to edit this field -- it's just what we would have put there ourselves. Here's an important optimization: hit the \u2303A key now, and Dexter will use the suggested description. A transaction can be saved if the account is filled in and the description field has either been edited or has a string created by an automatic fill. Note that the word \"description\" in the box is a placeholder that means \"the description goes here\" -- it is not auto-filled text. Fill in the Third Transaction The next transaction is from a posting with the description \"Transfer from Venmo\". It was sent by our friend, who is paying her half of the lunch at Glenwood. In the CSV file this record shows it was a deposit into the checking account. Your first inclination might be to classify this as miscellaneous income. But a much better idea is to assign it to the restaurant expense account. For one thing, it's a more accurate description of what occurred: the original expense was a \"flow\" from checking to the restaurant account, and this transaction should just be the reverse, from restaurant to checking. Another good reason to set the account to restaurant is for budgeting purposes. The first transaction took $70 out of the restaurant envelope, and if we set the account to expenses:food:restaurant here it will automatically put $35 back into the envelope. Here's an efficient way to clean up the description so it simply reads \"Transfer from Venmo\": Hit \u2303P, and the suggested description is displayed on the terminal, with the cursor at the end of the line. Type ESC-B two times to move the cursor back two words, then hit the left arrow key to move back one more character Type \u2303K to erase all the characters to the right of the curosr, then hit the return key Set the account to restaurant , the same as you did for the check earlier: type \u2303T to edit the account, then \"re\" and tab and return. Finally, let's add a comment to remind ourselves of what this payment was for. Hit \u2303N (the \"N\" is a mnemonic for \"note\") and enter \"Reiumbursement from Kate\". The filled in transaction will look like this: Type \u2303A to accept the changes and move on to the next transaction. Fill in the Fourth Transaction The next transaction was at a gas station in Kayenta, Arizona. Edit the description field. Hit \u2303P, and the suggested description is displayed on the terminal, with the cursor at the end of the line. Here is a way to edit that line with minimal keystrokes: type \u2303A to move the cursor to the front of the line type ESC F twice to move the cursor right after the \"v\" in \"Chev\" type \u2303K to erase the rest of the line type \"ron\" to fill out the rest of the business name The line should now say \"Kayenta Chevron\". Hit the return key and that line will be saved as the transaction description. This exercise illustrated another subtle point: when we're editing a field, keystrokes can have a different meaning. Here \u2303A meant \"move the cursor to the front of the line\", but in the main loop it means \"accept this transaction and move to the next one.\" The reason for this is that field editing is controlled by the GNU readline library and it uses its own meanings for keys. If you're used to editing shell commands the keys will be familiar and it won't be any trouble caused by different meanings when editing a line. Enter an expense category using \u2303T to edit the account field, type \"fu\" and tab to complete the line to \"fuel\", and hit return. This gas purchase was part of a trip to the Southwest. With a more realistic set of expense categories we would probably have an account named expenses:travel , maybe even with subcategories for air , hotel , etc . But even without that travel category we can keep track of trip expenses using tags. Choose a short but descriptive tag name, like \"swrt\", short for \"southwest road trip\". To add the tag, type \u2303G to bring up the line editor. Type \"swrt\" and hit return. We can add this tag to any transaction, and later we can make a report that shows all transactions tagged \"swrt\" to see what we spent on the trip. Type \u2303A to accept the changes and move on to the next transaction. Tag Syntax Tags are short strings of letters and digits. When they are displayed in reports they will have a hash symbol at the front. When you are entering them, you can type one or more tag names. The hash symbol is optional (Dexter adds it for you), and you can enter multiple tags, separating them by spaces or commas. Complete the Remaining Transactions The table below shows the complete list of unpaired transactions. We leave it as an exercise for you to continue using the loop in the review command to update the remaining transactions. If you want to take a shortcut, the database in the file named apr.dox (available on the GitHub repo) has these transaction filled in already. date amount original desc account extra Apr 1 $70 Check Check #153: Glenwood restaurant Apr 2 $5 WASH-IT EXPRESS Wash-It car Apr 3 $35 Transfer from Venmo Venmo restaurant comment Apr 3 $50 KAYENTA CHEV-XX6444 Kayenta Chevron car tg Apr 5 $25 Best Buy/NST Best Buy Lubbock household Apr 12 $65 HATCH CHILE Hatch Chile Market groceries Apr 15 $25 AMZN Mktp Amazon Marketplace household Apr 15 $15 AMZN Mktp Amazon Marketplace household Apr 21 $50 JERRYS HOME Jerry's household Apr 22 $20 JERRYS HOME Jerry's household return","title":"Review Unpaired Entries"},{"location":"tut_review/#review-unpaired-entries","text":"After importing a batch of CSV files, the pair command will automatically generate matches for most of the new postings, but there will probably be several more that need to be processed by hand. The select command (described in more detail in Select Transactions ) has a set of options that will print a table showing all the unpaired entries: $ dex select --entry --tag '#unpaired' \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 date \u2503 account \u2503 amount \u2503 column \u2503 description \u2503 tags \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 2024-04-01 \u2502 checking \u2502 $70.00 \u2502 credit \u2502 Check # 153: Completed/Check \u2026 \u2502 #unpaired \u2502 \u2502 2024-04-02 \u2502 visa \u2502 $5.00 \u2502 credit \u2502 WASH-IT EXPRESS \u2502 #unpaired \u2502 \u2502 2024-04-03 \u2502 checking \u2502 $35.00 \u2502 debit \u2502 Transfer from Venmo/VENMO - \u2026 \u2502 #unpaired \u2502 \u2502 2024-04-03 \u2502 checking \u2502 $50.00 \u2502 credit \u2502 KAYENTA CHEV-XX6444 JUNCTION \u2026 \u2502 #unpaired \u2502 ...","title":"Review Unpaired Entries"},{"location":"tut_review/#overview","text":"To start the review process simply type the command name: $ dex review Dexter will show us the unpaired postings one at a time. It will create the outline of a new transaction, leaving blanks for places we can fill in. The display will be a table that has the general shape of a transaction in Journal format: the top line will have the date and transaction description the next line will be the posting corresponding to the CSV record that was imported the third line will be the outline of a new posting where we need to supply the account name This is what the display looks like for the first entry shown above: The blanks we can fill in are shown with a light background and a reminder (in italics) of what goes in that blank. After we fill in the description and account fields for this transaction the display will look like this: The filled-in fields are displayed in a different color to indicate they have been edited. Every new transaction must have the description and account fields filled in; the comment and tags are optional. At this point we can save current transaction. They display will be updated to show the next unpaired entry from the list.","title":"Overview"},{"location":"tut_review/#philosophy","text":"The obvious question at this point is, why go to all the effort to make a new command just to review postings? Wouldn't it be easier to export the data to a spreadsheet of other application and let users work with a GUI they are already familiar with? The answer is that Dexter's command line interface is much more efficient. With a GUI display in a spreadsheet or text editor, users choose items that need to be updated. They click on an item and then edit one or more fields. Dexter knows which items need attention, and it displays them to us one at a time. The efficiency comes from being able to use features like command completion and command line editing to update the current item. In many cases it can take only a few keystrokes (and no mouse clicks) to fill in the missing data and move on to the next item.","title":"Philosophy"},{"location":"tut_review/#example","text":"Let's work through the steps used to edit the posting shown above, which will illustrate several of Dexter's time-saving operations. At each step we'll start an edting operation by typing a single keystroke. The notation \u2303X is short for \"control-X\", i.e. hold down the control key when typing X.","title":"Example"},{"location":"tut_review/#auto-fill-command","text":"The description field in a new transaction is blank because none of the regular expressions matched the description in the CSV record. The CSV description is useful, however, so Dexter saves it as part of the posting. You can see the CSV description (\"Check # 152: ...\") on the right part of the second line. The auto-fill command (\u2303F) copies information from the posting description and inserts it in the transaction description area. the first time we hit \u2303F Dexter copies the posting description the next time we type that Key Dexter will apply the \"fill\" and \"sub\" regular expressions mentioned briefly in Regular Expressions and insert the result if we hit \u2303F a third time the area goes back to the original blank state (with just the placeholder) This is what the terminal window shows after hitting \u2303F the first time: And this is the window after the second \u2303F: The regular expressions (described below) have stripped away all of the extra text following the colon. You can hit \u2303F a few more times to see how Dexter cycles through the three alternatives. Make sure it is displaying the third alternative (created by the regular expressions) before moving on to the next step.","title":"Auto-Fill Command"},{"location":"tut_review/#edit-the-description","text":"Notice how the text displayed in the transaction description area is still in italics. That's because the fill command simply makes suggestions for what the description should look like. We often want to edit the field to refine that suggestion. To edit the description field hit \u2303P. The \"P\" is short for \"payee\". We can't use \u2303D because that's a Unix convention for signalling the end of input and the command to exit the program. This is what the screen will look like: Whenever you are editing a field, Dexter will prompt you to enter the contents. It will print a line with the field name followed by a greater-than sign and then the current contents of the field. In this example, it printed the suggested contents of the description field. The cursor is at the end of the line, which means we just need to type in the name of the person or business we wrote the check to. Type \"Glenwood\" and hit the return key. Now the new transaction will look like this: The most important thing to notice here is that the text format has changed: it's now blue on a white background. That means the field has been edited and has a value that will be saved in the database.","title":"Edit the Description"},{"location":"tut_review/#command-line-editing","text":"Dexter uses a popular library named GNU Readline to control the editing of fields. You are probably already familiar with the keystrokes you can use, since most shells use this library (or an equivalent). use \u2303A or \u2303E to move the cursor to the front or end of the line use left-arrow and right-arrow keys or type \u2303B or \u2303F to move backward or forward one character type ESC followed by B or F to move backward or forward one word at a time type DEL to delete the character to the left, ESC DEL to delete the word to the left \u2303U deletes the entire line The complete set of editing keys can be found in the Reference section, in dex Review .","title":"Command Line Editing"},{"location":"tut_review/#edit-the-account-name","text":"To edit the account name in the new posting type \u2303T. The \"T\" is short for \"to\", since this posting is usually the destination (credit) account in the transaction. As before, Dexter prints a new line for you to enter the account name: This is where another traditional command line editing feature will be very useful. You can type part of a command name and then hit the tab key. If the part you typed is sufficient to distinguish the account from all the other accounts Dexter will fill in the rest of the name for you. This transaction is something that should go in the restaurant expenses category, expense:food:restaurant . That account has an abbreviation of \"restaurant\". Type \"re\" and hit the tab key. Dexter will fill in the rest, and the line will show \"restaurant\". Now hit the return key, and you can see Dexter has expanded the abbreviation into the full account name:","title":"Edit the Account Name"},{"location":"tut_review/#notes-on-line-completion","text":"If you're entering a string and hit the tab key and nothing happens it probably you didn't type enough to disambiguate the account you want from other accounts. Hit the tab key a second time and Dexter will show you all the accounts that start with the text you typed. For example, suppose you wanted to classify the Glenwood transaction as a household expense and want to assign expenses:home:household as the account. If you just type \"ho\" and hit tab nothing happens. Hit tab again and this is that you'll see: Dexter is saying there are two accounts that start with \"ho\": \"home\" and \"household\". At this point just continue typing. Since we want \"household\" in this case just typing \"u\" and tab is enough. Note: Another reason you won't see anything happen when you hit the tab key is that you misspelled an account name. For example, if you type \"hoo\" you can hit the tab key as often as you want. Dexter is telling you no account starts \"hoo\". If you really meant \"hou\" hit the delete key to erase the \"o\", then type \"u\" and tab.","title":"Notes on Line Completion"},{"location":"tut_review/#accept-changes","text":"The last step is to tell Dexter we're done with this transaction. Type \u2303A (the \"A\" is for \"accept\"). Dexter will add the new posting and the new transaction to the database and move on to the next unpaired posting.","title":"Accept Changes"},{"location":"tut_review/#exit","text":"To exit the program type \u2303C or \u2303D. You can verify the new transaction and posting were added to the database: if you run dex info you will see the count in those two columns has increased by one you can run the select command that prints the list of unpaired entries (shown at the top of this page) to see that the check posting is no longer on this list.","title":"Exit"},{"location":"tut_review/#restart","text":"When you restart Dexter to work on the remaining transactions add an option to the review command: dex review --fill_mode 2 That tells Dexter to automatically fill each transaction description. Mode number 2 is \"apply regular expressions to the posting description\". Now we don't have to type \u2303F -- it will be done already. If you want to use another mode for any transaction you can still type \u2303F to cycle through the modes.","title":"Restart"},{"location":"tut_review/#display-help","text":"If you need a reminder of which control keys trigger the editing operations just type a question mark when Dexter is showing a transaction. This message will be displayed:","title":"Display Help"},{"location":"tut_review/#fill-in-the-second-transaction","text":"The next transaction was a purchase at a car wash. We want to assign expenses:car as the account. If you type \u2303T to edit the account, type \"car\", and hit return you'll see an error message: The problem here is that we defined three accounts with the string \"car\" in the name. To fix this problem you need to type the full account name. But completion can still help save keystrokes. Type \"ex\" and tab, and the line will expand to \"expenses\". Now type a colon and \"ca\" and tab again, and the line will show \"expenses:car\". Hit return to enter that name in the transaction box. The display will look like this: Next, look at the filled in transaction description. The regular expression has transformed it into \"title-case\": the first letter in each word is capitalized, the rest are lower case. There's no need to edit this field -- it's just what we would have put there ourselves. Here's an important optimization: hit the \u2303A key now, and Dexter will use the suggested description. A transaction can be saved if the account is filled in and the description field has either been edited or has a string created by an automatic fill. Note that the word \"description\" in the box is a placeholder that means \"the description goes here\" -- it is not auto-filled text.","title":"Fill in the Second Transaction"},{"location":"tut_review/#fill-in-the-third-transaction","text":"The next transaction is from a posting with the description \"Transfer from Venmo\". It was sent by our friend, who is paying her half of the lunch at Glenwood. In the CSV file this record shows it was a deposit into the checking account. Your first inclination might be to classify this as miscellaneous income. But a much better idea is to assign it to the restaurant expense account. For one thing, it's a more accurate description of what occurred: the original expense was a \"flow\" from checking to the restaurant account, and this transaction should just be the reverse, from restaurant to checking. Another good reason to set the account to restaurant is for budgeting purposes. The first transaction took $70 out of the restaurant envelope, and if we set the account to expenses:food:restaurant here it will automatically put $35 back into the envelope. Here's an efficient way to clean up the description so it simply reads \"Transfer from Venmo\": Hit \u2303P, and the suggested description is displayed on the terminal, with the cursor at the end of the line. Type ESC-B two times to move the cursor back two words, then hit the left arrow key to move back one more character Type \u2303K to erase all the characters to the right of the curosr, then hit the return key Set the account to restaurant , the same as you did for the check earlier: type \u2303T to edit the account, then \"re\" and tab and return. Finally, let's add a comment to remind ourselves of what this payment was for. Hit \u2303N (the \"N\" is a mnemonic for \"note\") and enter \"Reiumbursement from Kate\". The filled in transaction will look like this: Type \u2303A to accept the changes and move on to the next transaction.","title":"Fill in the Third Transaction"},{"location":"tut_review/#fill-in-the-fourth-transaction","text":"The next transaction was at a gas station in Kayenta, Arizona. Edit the description field. Hit \u2303P, and the suggested description is displayed on the terminal, with the cursor at the end of the line. Here is a way to edit that line with minimal keystrokes: type \u2303A to move the cursor to the front of the line type ESC F twice to move the cursor right after the \"v\" in \"Chev\" type \u2303K to erase the rest of the line type \"ron\" to fill out the rest of the business name The line should now say \"Kayenta Chevron\". Hit the return key and that line will be saved as the transaction description. This exercise illustrated another subtle point: when we're editing a field, keystrokes can have a different meaning. Here \u2303A meant \"move the cursor to the front of the line\", but in the main loop it means \"accept this transaction and move to the next one.\" The reason for this is that field editing is controlled by the GNU readline library and it uses its own meanings for keys. If you're used to editing shell commands the keys will be familiar and it won't be any trouble caused by different meanings when editing a line. Enter an expense category using \u2303T to edit the account field, type \"fu\" and tab to complete the line to \"fuel\", and hit return. This gas purchase was part of a trip to the Southwest. With a more realistic set of expense categories we would probably have an account named expenses:travel , maybe even with subcategories for air , hotel , etc . But even without that travel category we can keep track of trip expenses using tags. Choose a short but descriptive tag name, like \"swrt\", short for \"southwest road trip\". To add the tag, type \u2303G to bring up the line editor. Type \"swrt\" and hit return. We can add this tag to any transaction, and later we can make a report that shows all transactions tagged \"swrt\" to see what we spent on the trip. Type \u2303A to accept the changes and move on to the next transaction.","title":"Fill in the Fourth Transaction"},{"location":"tut_review/#tag-syntax","text":"Tags are short strings of letters and digits. When they are displayed in reports they will have a hash symbol at the front. When you are entering them, you can type one or more tag names. The hash symbol is optional (Dexter adds it for you), and you can enter multiple tags, separating them by spaces or commas.","title":"Tag Syntax"},{"location":"tut_review/#complete-the-remaining-transactions","text":"The table below shows the complete list of unpaired transactions. We leave it as an exercise for you to continue using the loop in the review command to update the remaining transactions. If you want to take a shortcut, the database in the file named apr.dox (available on the GitHub repo) has these transaction filled in already. date amount original desc account extra Apr 1 $70 Check Check #153: Glenwood restaurant Apr 2 $5 WASH-IT EXPRESS Wash-It car Apr 3 $35 Transfer from Venmo Venmo restaurant comment Apr 3 $50 KAYENTA CHEV-XX6444 Kayenta Chevron car tg Apr 5 $25 Best Buy/NST Best Buy Lubbock household Apr 12 $65 HATCH CHILE Hatch Chile Market groceries Apr 15 $25 AMZN Mktp Amazon Marketplace household Apr 15 $15 AMZN Mktp Amazon Marketplace household Apr 21 $50 JERRYS HOME Jerry's household Apr 22 $20 JERRYS HOME Jerry's household return","title":"Complete the Remaining Transactions"},{"location":"tut_select/","text":"Select Transactions Before we continue with the expense tracking workflow let's take a short detour to introduce the select command. The general form of this command is $ dex select C1 C2 ... where the items following the word \"select\" are constraint options . Constraints can specify dates, account names, description patterns, and many other attributes of transactions. If no constraints are given Dexter prints all transactions in the database: $ dex select Transactions \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 date \u2503 credit \u2503 debit \u2503 amount \u2503 description \u2503 comment \u2503 tags \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 2024-04-01 \u2502 checking \u2502 restaurant \u2502 $70.00 \u2502 Check #153: Glenwood \u2502 \u2502 \u2502 \u2502 2024-04-02 \u2502 checking \u2502 mortgage \u2502 $1,000.00 \u2502 Mortgage \u2502 \u2502 \u2502 \u2502 2024-04-02 \u2502 visa \u2502 expenses:car \u2502 $5.00 \u2502 Wash-it Express \u2502 \u2502 \u2502 ... The complete list of constraints and other options can be found in dex select . In this section we'll just show a few that will be useful for exploring our initial set of transactions. Date Ranges Use --start_date or --end_date (or both) to limit the set of results to a particular range of dates. $ dex select --start_date 2024-04-21 --end_date 2024-04-22 Transactions \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 date \u2503 credit \u2503 debit \u2503 amount \u2503 description \u2503 comment \u2503 tags \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 2024-04-21 \u2502 visa \u2502 household \u2502 $50.00 \u2502 Jerry's Home Eugene \u2502 \u2502 \u2502 \u2502 2024-04-22 \u2502 visa \u2502 restaurant \u2502 $50.00 \u2502 Hey Neighbor \u2502 \u2502 \u2502 \u2502 2024-04-22 \u2502 visa \u2502 yard \u2502 $100.00 \u2502 Lane Forest Products \u2502 \u2502 \u2502 \u2502 2024-04-22 \u2502 yoyodyne \u2502 checking \u2502 $3,000.00 \u2502 Yoyodyne \u2502 \u2502 \u2502 \u2502 2024-04-22 \u2502 checking \u2502 utility \u2502 $100.00 \u2502 AT&T \u2502 \u2502 \u2502 \u2502 2024-04-22 \u2502 household \u2502 visa \u2502 $20.00 \u2502 Jerry's Home Eugene \u2502 return \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Amounts We can use --amount to specify an exact amount, in which case Dexter will print transactions only if they have this amount, or --min_amount and --max_amount to specify ranges. $ dex select --max_amount 10.00 Transactions \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 date \u2503 credit \u2503 debit \u2503 amount \u2503 description \u2503 comment \u2503 tags \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 2024-04-02 \u2502 visa \u2502 expenses:car \u2502 $5.00 \u2502 Wash-it Express \u2502 \u2502 \u2502 \u2502 2024-04-30 \u2502 interest \u2502 checking \u2502 $0.68 \u2502 Interest \u2502 \u2502 \u2502 \u2502 2024-04-30 \u2502 interest \u2502 savings \u2502 $1.59 \u2502 Interest \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Accounts TBD Entries The --entry option tells Dexter to print individual postings instead of transactions. Most of the other options, for dates, amounts, etc , are make sense for postings. $ dex select --entry --account food --full Entries \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 date \u2503 account \u2503 amount \u2503 column \u2503 description \u2503 tags \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 2024-04-01 \u2502 expenses:food:restaurant \u2502 $70.00 \u2502 debit \u2502 repl Check # 153: Completed/C\u2026 \u2502 \u2502 \u2502 2024-04-03 \u2502 expenses:food:restaurant \u2502 $35.00 \u2502 credit \u2502 repl Transfer from Venmo/VENM\u2026 \u2502 \u2502 \u2502 2024-04-12 \u2502 expenses:food:groceries \u2502 $65.00 \u2502 debit \u2502 repl HATCH CHILE MARKET \u2502 \u2502 \u2502 2024-04-22 \u2502 expenses:food:restaurant \u2502 $50.00 \u2502 debit \u2502 match TST* HEY NEIGHBOR - TBD \u2502 \u2502 \u2502 2024-04-23 \u2502 expenses:food:groceries \u2502 $15.00 \u2502 debit \u2502 match Everyone's Market/EVERY\u2026 \u2502 \u2502 \u2502 2024-04-24 \u2502 expenses:food:groceries \u2502 $15.00 \u2502 debit \u2502 match NEWMAN'S FISH COMPANY \u2502 \u2502 \u2502 2024-04-26 \u2502 expenses:food:groceries \u2502 $15.00 \u2502 debit \u2502 match LONGS MEAT MARKET \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Select Transactions"},{"location":"tut_select/#select-transactions","text":"Before we continue with the expense tracking workflow let's take a short detour to introduce the select command. The general form of this command is $ dex select C1 C2 ... where the items following the word \"select\" are constraint options . Constraints can specify dates, account names, description patterns, and many other attributes of transactions. If no constraints are given Dexter prints all transactions in the database: $ dex select Transactions \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 date \u2503 credit \u2503 debit \u2503 amount \u2503 description \u2503 comment \u2503 tags \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 2024-04-01 \u2502 checking \u2502 restaurant \u2502 $70.00 \u2502 Check #153: Glenwood \u2502 \u2502 \u2502 \u2502 2024-04-02 \u2502 checking \u2502 mortgage \u2502 $1,000.00 \u2502 Mortgage \u2502 \u2502 \u2502 \u2502 2024-04-02 \u2502 visa \u2502 expenses:car \u2502 $5.00 \u2502 Wash-it Express \u2502 \u2502 \u2502 ... The complete list of constraints and other options can be found in dex select . In this section we'll just show a few that will be useful for exploring our initial set of transactions.","title":"Select Transactions"},{"location":"tut_select/#date-ranges","text":"Use --start_date or --end_date (or both) to limit the set of results to a particular range of dates. $ dex select --start_date 2024-04-21 --end_date 2024-04-22 Transactions \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 date \u2503 credit \u2503 debit \u2503 amount \u2503 description \u2503 comment \u2503 tags \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 2024-04-21 \u2502 visa \u2502 household \u2502 $50.00 \u2502 Jerry's Home Eugene \u2502 \u2502 \u2502 \u2502 2024-04-22 \u2502 visa \u2502 restaurant \u2502 $50.00 \u2502 Hey Neighbor \u2502 \u2502 \u2502 \u2502 2024-04-22 \u2502 visa \u2502 yard \u2502 $100.00 \u2502 Lane Forest Products \u2502 \u2502 \u2502 \u2502 2024-04-22 \u2502 yoyodyne \u2502 checking \u2502 $3,000.00 \u2502 Yoyodyne \u2502 \u2502 \u2502 \u2502 2024-04-22 \u2502 checking \u2502 utility \u2502 $100.00 \u2502 AT&T \u2502 \u2502 \u2502 \u2502 2024-04-22 \u2502 household \u2502 visa \u2502 $20.00 \u2502 Jerry's Home Eugene \u2502 return \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Date Ranges"},{"location":"tut_select/#amounts","text":"We can use --amount to specify an exact amount, in which case Dexter will print transactions only if they have this amount, or --min_amount and --max_amount to specify ranges. $ dex select --max_amount 10.00 Transactions \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 date \u2503 credit \u2503 debit \u2503 amount \u2503 description \u2503 comment \u2503 tags \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 2024-04-02 \u2502 visa \u2502 expenses:car \u2502 $5.00 \u2502 Wash-it Express \u2502 \u2502 \u2502 \u2502 2024-04-30 \u2502 interest \u2502 checking \u2502 $0.68 \u2502 Interest \u2502 \u2502 \u2502 \u2502 2024-04-30 \u2502 interest \u2502 savings \u2502 $1.59 \u2502 Interest \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Amounts"},{"location":"tut_select/#accounts","text":"TBD","title":"Accounts"},{"location":"tut_select/#entries","text":"The --entry option tells Dexter to print individual postings instead of transactions. Most of the other options, for dates, amounts, etc , are make sense for postings. $ dex select --entry --account food --full Entries \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 date \u2503 account \u2503 amount \u2503 column \u2503 description \u2503 tags \u2503 \u2521\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2547\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2529 \u2502 2024-04-01 \u2502 expenses:food:restaurant \u2502 $70.00 \u2502 debit \u2502 repl Check # 153: Completed/C\u2026 \u2502 \u2502 \u2502 2024-04-03 \u2502 expenses:food:restaurant \u2502 $35.00 \u2502 credit \u2502 repl Transfer from Venmo/VENM\u2026 \u2502 \u2502 \u2502 2024-04-12 \u2502 expenses:food:groceries \u2502 $65.00 \u2502 debit \u2502 repl HATCH CHILE MARKET \u2502 \u2502 \u2502 2024-04-22 \u2502 expenses:food:restaurant \u2502 $50.00 \u2502 debit \u2502 match TST* HEY NEIGHBOR - TBD \u2502 \u2502 \u2502 2024-04-23 \u2502 expenses:food:groceries \u2502 $15.00 \u2502 debit \u2502 match Everyone's Market/EVERY\u2026 \u2502 \u2502 \u2502 2024-04-24 \u2502 expenses:food:groceries \u2502 $15.00 \u2502 debit \u2502 match NEWMAN'S FISH COMPANY \u2502 \u2502 \u2502 2024-04-26 \u2502 expenses:food:groceries \u2502 $15.00 \u2502 debit \u2502 match LONGS MEAT MARKET \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Entries"},{"location":"workflow/","text":"Monthly Workflow The standard workflow assumes transactions are saved in a database. Each month a new batch of CSVs is downloaded, added to the database, and refined into a set of transactions. Because the scripts that initialize a database can read .journal files from hledger there is an aternative workflow for users who just want to use Dexter to convert CSV files into transactions or for envelope budgeting. In this workflow, a temporary database is created using account definitions, new records are loaded from CSV files, and the results are written back out in a .journal format that can be read by hldeger. See hledger Workflow for details. Download CSVs In the current version of Dexter the records from a financial institution need to be saved in files that have names based on the account they will be loaded into. For example, if you have a Chase credit card, and the account you set up for it in Dexter is named liabilities:chase:visa , you will download a month's worth of transactions and rename it visa.csv . A future update will be able to work with CSV files downloaded from Mint.com and other \"aggregators\". These services automatically connect to financial institutions and then let you download a single CSV will all your transactions. In this case Dexter will get the account name from the CSV records instead of the CSV file name. Import CSVs If you move all your CSV files to the same folder you will be able to import them with a single command, e.g. $ dex import Downloads/* Each line in each CSV will become a single unpaired posting that needs to be matched with another posting in order to turn it into a transaction. Create Transactions The goal now is to create Transaction records by pairing the new postings using the pair command. There are two ways Dexter will do this: Dexter first looks for matching halves of transfers. For example, if you transfer money from your checking account to your savings account, Dexter will have found a debit in one CSV file and a credit in the other. The pair command will create a new transaction and save it in the database. Next it uses pattern matching rules. For example, we often buy fish at a store named \"Newman's Fish Market\". Our database has a rule that says whenver a credit card has a purchase at Newman's it can create a new debit posting to expenses:food:groceries and create a new transaction using the CSV record and the new posting. Review Unpaired Records There will always be postings that cannot be paired automatically. For example, if we buy something from Amazon.com, the record in the CSV file will simply have something like \"AMZN Mktp\" with no indication of what we purchased. In these cases we have to review the postings one at a time to clean up the description and assign an expense category. As described earlier, the review command uses a read-eval-print loop that lets us supply the missing information with a minimum of keystrokes. Fill Envelopes The next step is to add the transaction that fills the budget envelopes. Currently this is done by using a text editor to create a transaction in Journal format. Edit the transaction with to have the correct date and make sure the amounts balance, then import the file with dex import . A future update will add a new command, dex fill , that will automatically find the most recent deposits and create a new bucket transaction. Reports and Backups The remaining steps are optional. A select command can print a table showing transactions or postings that match various constraints. For example, this will print all recent grocery purchases that were more than $100: $ dex select --month may --min_amount 100.00 The report command can generate tables showing account balances, containing either individual records or a summary grouped by account name. Other commands described in the reference section include: dex save saves records in a JSON-like format as a way of backing up the database dex restore will create a new database from saved records dex list will print information about the database, for example lists of account names dex audit runs various consistency checks","title":"Workflow"},{"location":"workflow/#monthly-workflow","text":"The standard workflow assumes transactions are saved in a database. Each month a new batch of CSVs is downloaded, added to the database, and refined into a set of transactions. Because the scripts that initialize a database can read .journal files from hledger there is an aternative workflow for users who just want to use Dexter to convert CSV files into transactions or for envelope budgeting. In this workflow, a temporary database is created using account definitions, new records are loaded from CSV files, and the results are written back out in a .journal format that can be read by hldeger. See hledger Workflow for details.","title":"Monthly Workflow"},{"location":"workflow/#download-csvs","text":"In the current version of Dexter the records from a financial institution need to be saved in files that have names based on the account they will be loaded into. For example, if you have a Chase credit card, and the account you set up for it in Dexter is named liabilities:chase:visa , you will download a month's worth of transactions and rename it visa.csv . A future update will be able to work with CSV files downloaded from Mint.com and other \"aggregators\". These services automatically connect to financial institutions and then let you download a single CSV will all your transactions. In this case Dexter will get the account name from the CSV records instead of the CSV file name.","title":"Download CSVs"},{"location":"workflow/#import-csvs","text":"If you move all your CSV files to the same folder you will be able to import them with a single command, e.g. $ dex import Downloads/* Each line in each CSV will become a single unpaired posting that needs to be matched with another posting in order to turn it into a transaction.","title":"Import CSVs"},{"location":"workflow/#create-transactions","text":"The goal now is to create Transaction records by pairing the new postings using the pair command. There are two ways Dexter will do this: Dexter first looks for matching halves of transfers. For example, if you transfer money from your checking account to your savings account, Dexter will have found a debit in one CSV file and a credit in the other. The pair command will create a new transaction and save it in the database. Next it uses pattern matching rules. For example, we often buy fish at a store named \"Newman's Fish Market\". Our database has a rule that says whenver a credit card has a purchase at Newman's it can create a new debit posting to expenses:food:groceries and create a new transaction using the CSV record and the new posting.","title":"Create Transactions"},{"location":"workflow/#review-unpaired-records","text":"There will always be postings that cannot be paired automatically. For example, if we buy something from Amazon.com, the record in the CSV file will simply have something like \"AMZN Mktp\" with no indication of what we purchased. In these cases we have to review the postings one at a time to clean up the description and assign an expense category. As described earlier, the review command uses a read-eval-print loop that lets us supply the missing information with a minimum of keystrokes.","title":"Review Unpaired Records"},{"location":"workflow/#fill-envelopes","text":"The next step is to add the transaction that fills the budget envelopes. Currently this is done by using a text editor to create a transaction in Journal format. Edit the transaction with to have the correct date and make sure the amounts balance, then import the file with dex import . A future update will add a new command, dex fill , that will automatically find the most recent deposits and create a new bucket transaction.","title":"Fill Envelopes"},{"location":"workflow/#reports-and-backups","text":"The remaining steps are optional. A select command can print a table showing transactions or postings that match various constraints. For example, this will print all recent grocery purchases that were more than $100: $ dex select --month may --min_amount 100.00 The report command can generate tables showing account balances, containing either individual records or a summary grouped by account name. Other commands described in the reference section include: dex save saves records in a JSON-like format as a way of backing up the database dex restore will create a new database from saved records dex list will print information about the database, for example lists of account names dex audit runs various consistency checks","title":"Reports and Backups"}]}